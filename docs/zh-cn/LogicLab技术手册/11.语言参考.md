## 11. LANGUAGE REFERENCE 

All LogicLab languages are IEC 61131-3 standard-compliant.

\- Common elements

\- Instruction list (IL)

\- Function block diagram (FBD)

\- Ladder diagram (LD)

\- Structured text (ST)

\- Sequential Function Chart (SFC).

Moreover, LogicLab implements some extensions:

\- Pointers

\- Macros.

\- Object Oriented programming. 

### 11.1 COMMON ELEMENTS 

By common elements are intended those elements which are common to all programming 

languages of the IEC 61131-3 standard.

Note: definition and editing of most of the common elements (variables, structured elements,

function blocks definitions etc.) are managed by LogicLab through specific editors, forms

and tables.

The following paragraphs are meant to be a language specification. To correctly manage

common elements refer to the LogicLab user guide.

#### 11.1.1 BASIC ELEMENTS 

##### 11.1.1.1 CHARACTER SET 

Textual documents and textual elements of graphic languages are written by using the 

standard ASCII character set.

##### 11.1.1.2 COMMENTS 

User comments are delimited at the beginning and at the end by special character com

binations. For the textual languages (IL and ST) are allowed this format of comments:

\- (* *multi-lines comment* *)

\- // *single line comment*

*-* /* *multi-line comment* */

Same format comments cannot be 

nested.

Different format comments can be

nested but it is a strongly not

recommended practice.

For graphic languages, comments are inserted using dedicated commands; they are then 

translated, into the project file, using the first comment format *(\* comment \*).*

Comments are permitted anywhere in the program, and they have no syntactic or seman

tic significance in any of the languages defined in this standard.

LogicLab user manual 

165
#### 11.1.2 ELEMENTARY DATA TYPES 

A number of elementary (i.e. pre-defined) data types is made available by LogicLab, all 

compliant with IEC 61131-3 standard.

Elementary data types, keyword for each data type, number of bits per data element, and 

range of values for each elementary data type are described in the following table.

 Keyword  

 Description  

 Bits  

 Range / Notes 

BOOL 

Boolean 

See 

note

0 to 1 - size of the BOOL 

data type depends on the 

target device processor.

 e.g. it is 1 bit long for 

devices that have a bit

addressable area.

SINT 

Short integer 

8 

-128 to 127

USINT 

Unsigned short integer 

8 

0 to 255

INT 

Integer 

16 

-32768 to 32767

UINT 

Unsigned integer 

16 

0 to 65536

DINT 

Double integer 

32

−2147483648

to

 2147483647

UDINT 

Unsigned Double integer 

32 

0 to 4294967295

LINT 

Long integer 

64

−9223372036854775808

to

 9223372036854775807

ULINT 

Unsigned Long integer 

64 

0 to 

18446744073709551615

BYTE 

Bit string of length 8 

8 

—

WORD 

Bit string of length 16 

16 

—

DWORD 

Bit string of length 32 

32 

—

LWORD 

Bit stirng of length 64 

64 

—

REAL 

Real number 

32 

-3.40E+38 to +3.40E+38

LREAL 

Long Real Number 

64 

-1.7E+308 to +1.7E+308

STRING 

String of characters 

encoded with UTF-8 

— 

Characters are delimited by 

single quotes ( ‘abc’ )

WSTRING 

String of characters 

encoded with UTF-16 

— 

Characters are delimited by 

double quotes ( “abc” )

DATE

Date expressed in 

seconds, represented 

with format YYYY-MM-DD

32 

1970-01-01 to 2038-01-19

LDATE

Date expressed 

in nanoseconds, 

represented with format 

YYYY-MM-DD

64 

1970-01-01 to 2262-04-11

TIME

Time expressed in 

milliseconds represented 

with format dd_hh_mm_

ss_ms

32

 -24d_20h_31m_23s_648ms 

to 

24d_20h_31m_23s_647ms

166 

LogicLab user manual Keyword  

 Description  

 Bits  

 Range / Notes 

LTIME

Time expressed in 

nanoseconds represented 

with format dd_hh_mm_

ss_ms_us_ns

64

-106751d_23h_47m_16s_85

4ms_775us_808ns 

to 

106751d_23h_47m_16s_854

ms_775us_807ns

DATE_AND_TIME

Date expressed in 

seconds, represented 

with format YYYY-MM

DD-hh:mm:ss 

32

1970-01-01-00:00:00 

to

2038-01-19-03:14:07

LDATE_AND_TIME

Date expressed 

in nanoseconds, 

represented with format 

YYYY-MM-DD-hh:mm:ss.

us

64

1970-01-01-00:00:00

to

2262-04-11-23:47:16.854

TIME_OF_DAY

Time of the day 

expressed in 

milliseconds, represented 

with format hh:mm:ss.

ms

32

00:00:00

to

23:59:59.999

LTIME_OF_DAY

Time of the day 

expressed in 

nanoseconds, 

represented with format 

hh:mm:ss.ns

64

00:00:00

to

23:59:59.999999999

^ANY_TYPE 

Referece to a variable of 

any type (IEC standard) 

32 

See 11.1.2.1 for further 

information

##### 11.1.2.1 REFERENCES 

References are a standard IEC type that act as a pointer to another variable (the refer

enced variable). Reference type works like the pointer type (see paragraph 11.7.2), but 

the pointer type is not a standard IEC type and has several less restricion, which make the 

pointer type more flexible but also more dangerous than the reference type.

The value of the reference is the addess of the referenced variable; in order to access the 

data stored at the referenced address, a reference can be dereferenced.

Reference declaration requires the same syntax used in variable declaration, where the 

type name is the type name of the referenced variable with ^ sign after:

 

VAR

 

<reference_var_name> : <referenced_var_type>^;

 

END_VAR

For example, the declaration of a reference to an INT shall be as follows:

 

VAR

 

rInt : INT^;

 

END_VAR

Reference can be assigned with another reference or with an address; the special operator REF is 

available to retrieve the reference address of a variable.

rx := ry; 

(* where rx and ry are reference of the same type *)

rx := REF(x); (* where rx is a reference to the same type of x *)

LogicLab user manual 

167Accessing to the reference variable followed by the ^ sign, will dereference the variable:

rx := REF(x); 

(* rx i a reference to x *)

rx^ := 10; 

(* x vaule is now 10 *)

rx^ := rx^ + 1; 

(* x value now is 11 *)

y := rx^; 

(* y value now is 11, y is of the same type of x *)

For further information about references, please refer to IEC standard reference.

#### 11.1.3 DERIVED DATA TYPES 

Derived data types can be declared using the TYPE...END_TYPE construct. They can be 

used in variable declarations, in addition to the elementary data types.

Both single-element variables and elements of a multi-element variable, which are de

clared to be of derived data types, can be used anywhere where a variable of its parent 

type can be used.

##### 11.1.3.1 TYPEDEFS 

The purpose of typedefs is to assign alternative names to existing types. There are not 

any differences between a typedef and its parent type, except the name.

Typedefs can be declared using the following syntax:

TYPE 	

<enumerated data type name> : <parent type name>;

END_TYPE

For example, consider the following declaration, mapping the name LONGWORD to the IEC 

61131-3 standard type DWORD:

TYPE 	

longword : DWORD;

END_TYPE

##### 11.1.3.2 ENUMERATED DATA TYPES 

An enumerated data type declaration specifies that the value of any data element of that

type can only be one of the values given in the associated list of identifiers. The enumera

tion list defines an ordered set of enumerated values, starting with the first identifier of

the list, and ending with the last.

Enumerated data types can be declared using the following syntax:

TYPE 	

<enumerated data type name> : ( <enumeration list> );

END_TYPE

For example, consider the following declaration of two enumerated data types. Note that, 

when no explicit value is given to an identifier in the enumeration list, its value equals the

value assigned to the previous identifier augmented by one. 

TYPE

 enum1: (  		

val1, (* the value of val1 is 0 *) 		

val2, 

(* the value of val2 is 1 *) 		

val3 (* the value of val3 is 2 *)

 );

168 

LogicLab user manual enum2: ( 

 

k := -11, 

 

i := 0,  		

j,		

(* the value of j is ( i + 1 ) = 1 *) 		

l := 5

 );

END_TYPE

Different enumerated data types may use the same identifiers for enumerated values. In

order to be uniquely identified when used in a particular context, enumerated literals may

be qualified by a prefix consisting of their associated data type name and the # sign.

##### 11.1.3.3 SUBRANGES 

A subrange declaration specifies that the value of any data element of that type is re

stricted between and including the specified upper and lower limits.

Subranges can be declared using the following syntax:

TYPE 	

<subrange name> : <parent type name> ( <lower limit>..<upper limit> 

);

END_TYPE

For a concrete example consider the following declaration:

TYPE

 int_0_to_100 : INT (0..100);

END_TYPE

##### 11.1.3.4 STRUCTURES 

A STRUCT declaration specifies that data elements of that type shall contain sub-elements

of specified types which can be accessed by the specified names.

Structures can be declared using the following syntax:

TYPE 	

<structured type name> : STRUCT 		

<declaration of structurestructure elements>

 END_STRUCT;

END_TYPE

For example, consider the following declaration:

TYPE

 structure1 : STRUCT 		

elem1 : USINT; 		

elem2 : USINT; 		

elem3 : INT; 		

elem3 : REAL;

 END_STRUCT;

END_TYPE

LogicLab user manual 

169
#### 11.1.4 LITERALS 

##### 11.1.4.1 NUMERIC LITERALS 

External representation of data in the various programmable controller programming lan

guages consists of numeric literals.

There are two classes of numeric literals: integer literals and real literals. A numeric literal 

is defined as a decimal number or a based number.

Decimal literals are represented in conventional decimal notation. Real literals are dis

tinguished by the presence of a decimal point. An exponent indicates the integer power 

of ten by which the preceding number needs to be multiplied to obtain the represented 

value. Decimal literals and their exponents can contain a preceding sign (+ or -).

Integer literals can also be represented in base 2, 8 or 16. The base is in decimal notation. 

For base 16, an extended set of digits consisting of letters A through F is used, with the 

conventional significance of decimal 10 through 15, respectively. Based numbers do not

contain any leading sign (+ or -).

Boolean data are represented by the keywords FALSE or TRUE.

Numerical literal features and examples are shown in the table below.

 Feature description  

 Examples 

Integer literals 

-12 0 123 +986

Real literals 

-12.0 0.0 0.4560

Real literals with exponents

-1.34E-12 or -1.34e-12

1.0E+6 or 1.0e+6

1.234E6 or 1.234e6

Base 2 literals 

2#11111111 (256 decimal)

2#11100000 (240 decimal)

Base 8 literals 

8#377 (256 decimal)

8#340 (240 decimal)

Base 16 literals 

16#FF or 16#ff (256 decimal)

16#E0 or 16#e0 (240 decimal)

Boolean FALSE and TRUE 

FALSE TRUE

##### 11.1.4.2 CHARACTER STRING LITERALS 

A character string literal is a sequence of zero or more characters prefixed and terminated

by the single quote character (').

The three-character combination of the dollar sign ($) followed by two hexadecimal digits 

shall be interpreted as the hexadecimal representation of the eight-bit character code.

 Example  

 Explanation 

'' 

Empty string (length zero)

'A' 

String of length one containing the single character A

' ' 

String of length one containing the  space  character

'$'' 

String of length one containing the  single quote  character

'”' 

String of length one containing the  double quote  character

'$R$L' String of length two containing CR and LF characters

'$0A' 

String of length one containing the LF character

170 

LogicLab user manualTwo-character combinations beginning with the dollar sign shall be interpreted as shown 

in the following table when they occur in character strings.

 Combination  

 Interpretation when printed 

$$ 

Dollar sign

$' 

Single quote

$L or $1 

Line feed

$N or $n 

Newline

$P or $p 

Form feed (page)

$R or $r 

Carriage return

$T or $t 

Tab

#### 11.1.5 VARIABLES 

##### 11.1.5.1 FOREWORD 

Variables provide a means of identifying data objects whose contents may change, e.g., 

data associated with the inputs, outputs, or memory of the programmable controller. A 

variable must be declared to be one of the elementary types. Variables can be represent

ed symbolically, or alternatively in a manner which directly represents the association of 

the data element with physical or logical locations in the programmable controller’s input, 

output, or memory structure.

Each program organization unit (POU) (i.e., each program, function, or function block) 

contains at its beginning at least one declaration part, consisting of one or more structur

ing elements, which specify the types (and, if necessary, the physical or logical location) 

of the variables used in the organization unit. This declaration part has the textual form of 

one of the keywords VAR, VAR_INPUT, or VAR_OUTPUT as defined in the keywords section,

followed in the case of VAR by zero or one occurrence of the qualifiers RETAIN, NON_RE

TAIN or the qualifier CONSTANT, and in the case of VAR_INPUT or VAR_OUTPUT by zero or 

one occurrence of the qualifier RETAIN or NON_RETAIN, followed by one or more decla

rations separated by semicolons and terminated by the keyword END_VAR. A declaration 

may also specify an initialization for the declared variable, when a programmable control

ler supports the declaration by the user of initial values for variables.

##### 11.1.5.2 STRUCTURING ELEMENT 

The declaration of a variable must be performed within the following program structuring 

element:

KEYWORD [RETAIN] [CONSTANT]

 Declaration 1

 Declaration 2

...

 Declaration N

END_VAR 

 11.1.5.3 KEYWORDS AND SCOPE 

 Keyword  

 Variable usage 

VAR 

Internal to organization unit.

VAR_INPUT 

Externally supplied.

LogicLab user manual 

171 Keyword  

 Variable usage 

VAR_OUTPUT 

Supplied by organization unit to external 

entities.

VAR_IN_OUT 

Supplied by external entities, can be 

modified within organization unit.

VAR_EXTERNAL Supplied 

by configuration 

via VAR_GLOBAL

, 

can be modified 

within organization 

unit.

VAR_GLOBAL 

Global variable declaration.

The scope (range of validity) of the declarations contained in structuring elements is local 

to the program organization unit (POU) in which the declaration part is contained. That 

is, the declared variables are accessible to other program organization units except by 

explicit argument passing via variables which have been declared as inputs or outputs of 

those units. The one exception to this rule is the case of variables which have been de

clared to be global. 

Such variables are accessible to programs in any case, or via a VAR_EXTERNAL declaration 

to function blocks. The type of a variable declared in a VAR_EXTERNAL must agree with the 

type declared in the VAR_GLOBAL block.

To give access to this variables to all type of POU, without using any keyword, you must 

enable this option in the code generation tab of the project options (see Paragraph 4.6.2).

There is an error if:

\- any program organization unit attempts to modify the value of a variable that has been 

declared with the CONSTANT qualifier;

\- a variable declared as VAR_GLOBAL CONSTANT in a configuration element or program or

ganization unit (the “containing element”) is used in a VAR_EXTERNAL declaration (with

out the CONSTANT qualifier) of any element contained within the containing element.

##### 11.1.5.4 QUALIFIERS 

 Qualifier  

 Description 

CONST

The attribute CONST indicates that the variables within 

the structuring elements are constants, i.e. they have 

a constant value, which cannot be modified once the

PLC project has been compiled.

RETAIN

The attribute RETAIN indicates that the variables 

within the structuring elements are retentive, i.e. they 

keep their value even after the target device is reset 

or switched off.

##### 11.1.5.5 SINGLE-ELEMENT VARIABLES AND ARRAYS 

A single-element variable represents a single data element of either one of the elemen

tary types or one of the derived data types.

An array is a collection of data elements of the same data type; in order to access a single 

element of the array, a subscript (or index) enclosed in square brackets has to be used. 

Subscripts can be either integer literals or single-element variables.

To easily represent data matrices, arrays can be multi-dimensional; in this case, a com

posite subscript is required, one index per dimension, separated by commas. The maxi

mum number of dimensions allowed in the definition of an array is three.

172 

LogicLab user manual
##### 11.1.5.6 DECLARATION SYNTAX 

Variables must be declared within structuring elements, using the following syntax:

VarName1 : Typename1 [ := InitialVal1 ];

VarName2 AT Location2 : Typename2 [ := InitialVal2 ];

VarName3 : ARRAY [ 0..N ] OF Typename3;

where:

 Keyword  

 Description 

VarNameX

Variable identifier, consisting of a string of

alphanumeric characters, of length 1 or more. It is 

used for symbolic representation of variables.

TypenameX 

Data type of the variable, selected from elementary 

data types.

InitialValX The value the variable assumes after reset of the 

target.

LocationX 

See the next paragraph.

N 

Index of the last element, the array having length 

N + 1.

##### 11.1.5.7 LOCATION 

Variables can be represented symbolically, i.e. accessed through their identifier, or alter

natively in a manner which directly represents the association of the data element with 

physical or logical locations in the programmable controller’s input, output, or memory 

structure.

Direct representation of a single-element variable is provided by a special symbol formed 

by the concatenation of the percent sign “%” , a location prefix and a size prefix, and one

or two unsigned integers, separated by periods (.).

%location size index.subindex

1) location

The location prefix may be one of the following:

 Location prefix  

 Description 

I 

Input location

Q 

Output location

M 

Memory location

2) size

The size prefix may be one of the following:

 Size prefix  

 Description 

X 

Single bit size

B 

Byte (8 bits) size

W 

Word (16 bits) size

D 

Double word (32 bits) size

L 

Long word (64 bits) size

R 

Real (32 bits) size

Q 

Lorg real (64 bits) size

LogicLab user manual 

1733) index.index

This sequence of unsigned integers, separated by dots, specifies the actual position

of the variable in the area specified by the location prefix.

 Example: 

 Direct representation  

 Description 

%MW4.6 

Word starting from the first byte of the 7th

element of memory datablock 4.

%IX0.4 

First bit of the first byte of the 5th element 

of input set 0.

Note that the absolute position depends on the size of the datablock elements, not on the 

size prefix. As a matter of fact, %MW4.6 and %MD4.6 begin from the same byte in memory, 

but the former points to an area which is 16 bits shorter than the latter.

For advanced users only: if the index consists of one integer only (no dots), then it loses 

any reference to data blocks, and it points directly to the byte in memory having the index 

value as its absolute address.

 Direct representation  

 Description 

%MW4.6 

Word starting from the first byte of the 7th

element of datablock 4 in memory.

%MW4 

Word starting from byte 4 of memory.

 Example 

VAR [RETAIN] [CONSTANT]

XQuote : DINT; 

Enabling : BOOL := FALSE;

TorqueCurrent AT %MW4.32 : INT;

Counters : ARRAY [ 0 .. 9 ] OF UINT;

Limits: ARRAY [0..3, 0..9]

END_VAR

\- Variable XQuote is 32 bits long, and it is automatically allocated by the LogicLab com

piler.

\- Variable Enabling is initialized to FALSE after target reset. 

\- Variable TorqueCurrent is allocated in the memory area of the target device, and it 

takes 16 bits starting from the first byte of the 33

rd element of datablock 4. 

\- Variable Counters is an array of 10 independent variables of type unsigned integer. 

##### 11.1.5.8 DECLARING VARIABLES IN LOGICLAB 

Whatever the PLC language you are using, LogicLab allows you to disregard the syntax 

above, as it supplies the Local variables editor, the Global variables editor, and the Param

eters editor, which provide a friendly interface to declare all kinds of variables. 

#### 11.1.6 PROGRAM ORGANIZATION UNITS 

Program organization units are functions, function blocks, and programs. Program Organ

ization Units can be delivered by the manufacturer, or programmed by the user through 

the means defined in this part of the standard

Program organization units are not recursive; that is, the invocation of a program organi

zation unit cannot cause the invocation of another program organization unit of the same 

type.

174 

LogicLab user manual
##### 11.1.6.1 FUNCTIONS  

 Introduction 

For the purposes of programmable controller programming languages, a function is de

fined as a program organization unit (POU) which, when executed, yields exactly one data

element, which is considered to be the function result.

Functions contain no internal state information, i.e., invocation of a function with the 

same arguments (input variables VAR_INPUT and in-out variables VAR_IN_OUT) always 

yields the same values (output variables VAR_OUTPUT, in-out variables VAR_IN_OUT and 

function result).

 Declaration syntax 

The declaration of a function must be performed as follows:

FUNCTION FunctionName : RetDataType

VAR_INPUT

declaration of input variables (see the relevant section)

END_VAR

VAR

declaration of local variables (see the relevant section)

END_VAR

Function body

END_FUNCTION

 Keyword  

 Description 

FunctionName 

Name of the function being declared.

RetDataType 

Data type of the value to be returned by the function.

Function body

Specifies the operations to be performed upon the

input variables in order to assign values dependent on 

the function’s semantics to a variable with the same 

name as the function, which represents the function 

result. It can be written in any of the languages 

supported by LogicLab.

 Declaring functions in LogicLab 

Whatever the PLC language you are using, LogicLab allows you to disregard the syntax 

above, as it supplies a friendly interface for using functions.

##### 11.1.6.2 FUNCTION BLOCKS 

 Introduction 

For the purposes of programmable controller programming languages, a function block is 

a program organization unit which, when executed, yields one or more values. Multiple, 

named instances (copies) of a function block can be created. Each instance has an associ

ated identifier (the instance name), and a data structure containing its input, output and

internal variables. All the values of the output variables and the necessary internal vari

ables of this data structure persist from one execution of the function block to the next; 

therefore, invocation of a function block with the same arguments (input variables) does 

not always yield the same output values.

Only the input and output variables are accessible outside of an instance of a function 

block, i.e., the function block’s internal variables are hidden from the user of the function 

block.

In order to execute its operations, a function block needs to be invoked by another POU. 

LogicLab user manual 

175Invocation depends on the specific language of the module calling the function block.

The scope of an instance of a function block is local to the program organization unit in 

which it is instantiated.

 Declaration syntax 

The declaration of a function must be performed as follows:

FUNCTION_BLOCK FunctionBlockName

 VAR_INPUT

 declaration of input variables (see the relevant section)

 END_VAR

 VAR_OUTPUT

 declaration of output variables

 END_VAR

 VAR_EXTERNAL

 declaration of external variables

 END_VAR

 VAR

 declaration of local variables

 END_VAR

Function block body

END_FUNCTION_BLOCK

 Keyword  

 Description 

FunctionBlockName 

Name of the function block being declared (note: 

name of the template, not of its instances).

VAR_EXTERNAL .. END_VAR

A function block can access global variables only 

if they are listed in a VAR_EXTERNAL structuring 

element. Variables passed to the FB via a VAR_

EXTERNAL construct can be modified from within the

FB.

Function block body

Specifies the operations to be performed upon the

input variables in order to assign values to the 

output variables - dependent on the function block’s 

semantics and on the value of the internal variables. 

It can be written in any of the languages supported 

by LogicLab.

 Declaring functions in LogicLab 

Whatever the PLC language you are using, LogicLab allows you to disregard the syntax 

above, as it supplies a friendly interface for using function blocks.

##### 11.1.6.3 PROGRAMS 

 Introduction 

A program is defined in IEC 61131-1 as a “logical assembly of all the programming lan

guage elements and constructs necessary for the intended signal processing required for 

the control of a machine or process by a programmable controller system”.

 Declaration syntax 

176 

LogicLab user manualThe declaration of a program must be performed as follows:

PROGRAM < program name>

Declaration of variables (see the relevant section)

Program body

END_PROGRAM

 Keyword  

 Description 

Program Name 

Name of the program being declared.

Program body

Specifies the operations to be performed to get the

intended signal processing. It can be written in any of 

the languages supported by LogicLab.

 Writing programs in LogicLab 

Whatever the PLC language you are using, LogicLab allows you to disregard the syntax 

above, as it supplies a friendly interface for writing programs.

#### 11.1.7 OBJECT ORIENTED REFERENCE 

Object Oriented feature is achieved by enhancing the function block POU, there is not a 

specific element of type “class”.

This way a function block can have methods, which are handled like functions except that 

they can see the relative function block context.

A function block can extends another function block (only one) in a father-child hierarchy; 

and can implements any number of interfaces.

Interfaces are handled like new type definitions and allow the user to specify a list of

method prototypes composed of name and expected input variables; also interfaces can 

extends other interfaces (max one) in a father-child hierarchy.

If a function block implements one or more interfaces, it must correctly implements all of 

their methods in order to succesfully complete a project compilation.

LogicLab can handle polimorphysm on both function blocks and interfaces.

#### 11.1.8 IEC 61131-3 STANDARD FUNCTIONS 

This paragraph is a reference of all IEC 61131-3 standard functions available in LogicLab, 

along with a few others, which may be considered as LogicLab’s extensions to the stand

ard.

These functions are common to the whole set of programming languages and can there

fore be used in any Programmable Organization Unit (POU).

A function specified in this paragraph to be extensible (Ext.) is allowed to have a variable

number of inputs.

 Type conversion functions 

According to the IEC 61131-3 standard, type conversion functions shall have the form *_

TO_ , where “*” is the type of the input variable, and “ ” the type of the output variable 

(for example, INT_TO_REAL). LogicLab provides a more convenient set of overloaded type 

conversion functions, relieving the developer to specify the input variable type.

 TO_BOOL 

 Description  

Conversion to BOOL (boolean)

 Number of operands  1

LogicLab user manual 

177 TO_BOOL 

 Input data type  

Any numerical type

 Output data type  

BOOL

 Examples 

out := TO_BOOL( 0 ); (* out = FALSE *)

out := TO_BOOL( 1 ); (* out = TRUE *)

out := TO_BOOL( 1000 ); (* out = TRUE *)

 TO_BYTE 

 Description  

Conversion to BYTE (8-bit string)

 Number of operands  1

 Input data type  

Any numerical type or STRING

 Output data type  

BYTE

 Examples  

out := TO_BYTE( -1 ); (* out = 16#FF *)

out := TO_BYTE( 16#100 ); (* out = 16#00 *)

 TO_DATE 

 Description  

Conversion to DATE (32-bit signed integer)

 Number of operands  1

 Input data type  

DATE_AND_TIME, LDATE_AND_TIME, LDATE

 Output data type  

DATE

 Examples 

 TO_DATE_AND_TIME 

 Description  

Conversion to DATE_AND_TIME (32-bit signed integer)

 Number of operands  1

 Input data type  

LDATE_AND_TIME

 Output data type  

DATE_AND_TIME

 Examples 

 TO_DINT 

 Description  

Conversion to DINT (32-bit signed integer)

 Number of operands  1

 Input data type  

Any numerical type or STRING

 Output data type  

DINT

 Examples  

out := TO_DINT( 10.0 ); (* out = 10 *)

out := TO_DINT( 16#FFFFFFFF ); (* out = -1 *)

 TO_DWORD 

 Description  

Conversion to DWORD (32-bit string)

 Number of operands  1

 Input data type  

Any numerical type or STRING

 Output data type  

DWORD

178 

LogicLab user manual TO_DWORD 

 Examples  

out := TO_DWORD( 10.0 ); (* out = 16#0000000A *)

out := TO_DWORD( -1 ); (* out = 16#FFFFFFFF *)

 TO_INT 

 Description  

Conversion to INT (16-bit signed integer)

 Number of operands  1

 Input data type  

Any numerical type or STRING

 Output data type  

INT

 Examples  

out := TO_INT( -1000.0 ); (* out = -1000 *)

out := TO_INT( 16#8000 ); (* out = -32768 *)

 TO_LDATE 

 Description  

Conversion to LDATE (64-bit signed integer)

 Number of operands  1

 Input data type  

DATE_AND_TIME, LDATE_AND_TIME, DATE

 Output data type  

LDATE

 Examples 

 TO_LDATE_AND_TIME 

 Description  

Conversion to LDATE_AND_TIME (64-bit signed integer)

 Number of operands  1

 Input data type  

DATE_AND_TIME

 Output data type  

LDATE_AND_TIME

 Examples 

 TO_LINT 

 Description  

Conversion to LINT (64-bit signed integer)

 Number of operands  1

 Input data type  

Any numerical type or STRING

 Output data type  

LINT

 Examples  

out := TO_LINT( -1 ); (* out = -1 *)

out := TO_LINT(16#FFFFFFFFFFFFFFFF); (* out = -1 *)

 TO_LREAL 

 Description  

Conversion to LREAL (64-bit floating point)

 Number of operands  1

 Input data type  

Any numerical type or STRING

 Output data type  

LREAL

 Examples  

out := TO_LREAL( -1000 ); (* out = -1000.0 *)

out := TO_LREAL( 16#8000 ); (* out = -32768.0 *)

LogicLab user manual 

179 TO_LTIME 

 Description  

Conversion to LTIME (64-bit signed integer)

 Number of operands  1

 Input data type  

TIME

 Output data type  

LTIME

 Examples 

 TO_LTIME_OF_DAY 

 Description  

Conversion to LTIME_OF_DAY (64-bit signed integer)

 Number of operands  1

 Input data type  

TIME_OF_DAY, DATE_AND_TIME, LDATE_AND_TIME

 Output data type  

LTIME_OF_DAY

 Examples 

 TO_LWORD 

 Description  

Conversion to LWORD (64-bit unsigned integer)

 Number of operands  1

 Input data type  

Any numerical type or STRING

 Output data type  

LWORD

 Examples 

out := TO_LWORD( 10.0 ); (* out = 

16#000000000000000A *)

out := TO_LWORD( -1 ); (* out = 16#FFFFFFFFFFFFFFFF 

*)

 TO_POINTER 

 Description  

Conversion to pointer

 Number of operands  1

 Input data type  

Any numerical type or STRING

 Output data type  

REAL

 Examples  

out := TO_POINTER( -1000 );

 TO_REAL 

 Description  

Conversion to REAL (32-bit floating point)

 Number of operands  1

 Input data type  

Any numerical type or STRING

 Output data type  

REAL

 Examples  

out := TO_REAL( -1000 ); (* out = -1000.0 *)

out := TO_REAL( 16#8000 ); (* out = -32768.0 *)

 TO_SINT 

 Description  

Conversion to SINT (8-bit signed integer)

 Number of operands  1

 Input data type  

Any numerical type or STRING

180 

LogicLab user manual TO_SINT 

 Output data type  

SINT

 Examples  

out := TO_SINT( -1 ); (* out = -1 *)

out := TO_SINT( 16#100 ); (* out = 0 *)

 TO_STRING 

 Description  

Conversion to STRING

 Number of operands  1

 Input data type  

Any numerical type

 Output data type  

STRING

 Examples  

str := TO_STRING( 10.0 ); (* str = ‘10,0’ *)

str := TO_STRING( -1 ); (* str = ‘-1’ *)

 TO_TIME 

 Description  

Conversion to LTIME (32-bit signed integer)

 Number of operands  1

 Input data type  

LTIME

 Output data type  

TIME

 Examples 

 TO_TIME_OF_DAY 

 Description  

Conversion to TIME_OF_DAY (32-bit signed integer)

 Number of operands  1

 Input data type  

LTIME_OF_DAY, DATE_AND_TIME, LDATE_AND_TIME

 Output data type  

TIME_OF_DAY

 Examples 

 TO_UDINT 

 Description  

Conversion to UDINT (32-bit unsigned integer)

 Number of operands  1

 Input data type  

Any numerical type or STRING

 Output data type  

UDINT

 Examples 

out := TO_UDINT( 10.0 ); (* out = 10 *)

out := TO_UDINT( 16#FFFFFFFF ); (* out = 4294967295 

*)

 TO_UINT 

 Description  

Conversion to UINT (16-bit unsigned integer)

 Number of operands  1

 Input data type  

Any numerical type or STRING

 Output data type  

UINT

 Examples  

out := TO_UINT( 1000.0 ); (* out = 1000 *)

out := TO_UINT( 16#8000 ); (* out = 32768 *)

LogicLab user manual 

181 TO_ULINT 

 Description  

Conversion to ULINT (64-bit unsigned integer)

 Number of operands  1

 Input data type  

Any numerical type or STRING

 Output data type  

ULINT

 Examples 

out := TO_ULINT( 10.0 ); (* out = 10 *)

out := TO_ULINT( 16#FFFFFFFFFFFFFFFF ); (* out = 

18446744073709551615 *)

 TO_USINT 

 Description  

Conversion to USINT (8-bit unsigned integer)

 Number of operands  1

 Input data type  

Any numerical type or STRING

 Output data type  

USINT

 Examples  

out := TO_USINT( -1 ); (* out = 255 *)

out := TO_USINT( 16#100 ); (* out = 0 *)

 TO_WORD 

 Description  

Conversion to WORD (16-bit string)

 Number of operands  1

 Input data type  

Any numerical type or STRING

 Output data type  

WORD

 Examples  

out := TO_WORD( 1000.0 ); (* out = 16#03E8 *)

out := TO_WORD( -32768 ); (* out = 16#8000 *)

 TO_WSTRING 

 Description  

Conversion to WSTRING

 Number of operands  1

 Input data type  

Any numerical type

 Output data type  

WSTRING

 Examples  

wstr := TO_STRING( 10.0 ); (* wstr = “10,0” *)

wstr := TO_STRING( -1 ); (* wstr = “-1” *)

 Numerical functions 

The availability of the following functions depends on the target device. Please refer to 

your hardware supplier for details.

 ABS 

 Description  

Absolute value. Computes the absolute value of the input

 Number of operands  1

 Input data type  

Any numerical type

 Output data type  

Same as input

182 

LogicLab user manual ABS 

 Examples 

OUT := ABS( -5 );(* OUT = 5 *)

OUT := ABS( -1.618 );(* OUT = 1.618 *)

OUT := ABS( 3.141592 );(* OUT = 3.141592 *)

 ACOS 

 Description  

Arc cosine. Computes the principal arc cosine of input #0; 

result is expressed in radians

 Number of operands  1

 Input data type  

LREAL where available, REAL otherwise

 Output data type  

LREAL where available, REAL otherwise

 Examples  

OUT := ACOS( 1.0 ); (* OUT = 0.0 *)

OUT := ACOS( -1.0 ); (* OUT = PI *)

 ADD 

 Description  

Arithmetic addition. Computes the sum of the two inputs.

 Number of operands  2

 Input data type  

Any numerical type, Any numerical type

 Output data type  

Same as Inputs

 Examples  

OUT := ADD( 20, 40 ); (* OUT = 60 *)

 ASIN 

 Description  

Arc sine. Computes the principal arc sine of input #0; result 

is expressed in radians

 Number of operands  1

 Input data type  

LREAL where available, REAL otherwise

 Output data type  

LREAL where available, REAL otherwise

 Examples  

OUT := ASIN( 0.0 ); (* OUT = 0.0 *)

OUT := ASIN( 1.0 ); (* OUT = PI / 2 *)

 ATAN 

 Description  

Arc tangent. Computes the principal arc tangent of input 

\#0; result is expressed in radians

 Number of operands  1

 Input data type  

LREAL where available, REAL otherwise

 Output data type  

LREAL where available, REAL otherwise

 Examples  

OUT := ATAN( 0.0 ); (* OUT = 0.0 *)

OUT := ATAN( 1.0 ); (* OUT = PI / 4 *)

 ATAN2\ *

 Description  

Arc tangent (with 2 parameters). Computes the principal arc 

tangent of Y/X; result is expressed in radians

 Number of operands  2

LogicLab user manual 

183 ATAN2\ *

 Input data type  

LREAL where available, REAL otherwise;

LREAL where available, REAL otherwise

 Output data type  

LREAL where available, REAL otherwise

 Examples 

OUT := ATAN2( 0.0, 1.0 ); (* OUT = 0.0 *)

OUT := ATAN2( 1.0, 1.0 ); (* OUT = PI / 4 *)

OUT := ATAN2( -1.0, -1.0 ); (* OUT = ( -3/4 ) * PI 

*)

OUT := ATAN2( 1.0, 0.0 ); (* OUT = PI / 2 *)

 CEIL\ *

 Description  

Rounding up to integer. Returns the smallest integer that is 

greater than or equal to input #0

 Number of operands  1

 Input data type  

LREAL where available, REAL otherwise

 Output data type  

LREAL where available, REAL otherwise

 Examples  

OUT := CEIL( 1.95 ); (* OUT = 2.0 *)

OUT := CEIL( -1.27 ); (* OUT = -1.0 *)

 COS 

 Description  

Cosine. Computes the cosine function of input #0 expressed 

in radians

 Number of operands  1

 Input data type  

LREAL where available, REAL otherwise

 Output data type  

LREAL where available, REAL otherwise

 Examples  

OUT := COS( 0.0 ); (* OUT = 1.0 *)

OUT := COS( -3.141592 ); (* OUT ~ -1.0 *)

 COSH\ *

 Description  

Hyperbolic cosine. Computes the hyperbolic cosine function 

of input #0

 Number of operands  1

 Input data type  

LREAL where available, REAL otherwise

 Output data type  

LREAL where available, REAL otherwise

 Examples  

OUT := COSH( 0.0 ); (* OUT = 1.0 *)

 DIV 

 Description  

Arithmetic division. Divides input #0 by input #1

 Number of operands  2

 Input data type  

Any numerical type, Any numerical type

 Output data type  

Same as Inputs

 Examples  

OUT := DIV( 20, 2 ); (* OUT = 10 *)

184 

LogicLab user manual EXP 

 Description  

Natural exponential. Computes the exponential function of 

input #0

 Number of operands  1

 Input data type  

LREAL where available, REAL otherwise

 Output data type  

LREAL where available, REAL otherwise

 Examples  

OUT := EXP( 1.0 ); (* OUT ~ 2.718281 *)

 FLOOR\ *

 Description  

Rounding down to integer. Returns the largest integer that is 

less than or equal to input #0

 Number of operands  1

 Input data type  

LREAL where available, REAL otherwise

 Output data type  

LREAL where available, REAL otherwise

 Examples  

OUT := FLOOR( 1.95 ); (* OUT = 1.0 *)

OUT := FLOOR( -1.27 ); (* OUT = -2.0 *)

 LN 

 Description  

Natural logarithm. Computes the logarithm with base e of 

input #0

 Number of operands  1

 Input data type  

LREAL where available, REAL otherwise

 Output data type  

LREAL where available, REAL otherwise

 Examples  

OUT := LN( 2.718281 ); (* OUT = 1.0 *)

 LOG 

 Description  

Common logarithm. Computes the logarithm with base 10 of 

input #0

 Number of operands  1

 Input data type  

LREAL where available, REAL otherwise

 Output data type  

LREAL where available, REAL otherwise

 Examples  

OUT := LOG( 100.0 );(* OUT = 2.0 *)

 MOD 

 Description  

Module. Computes input #0 module input #1

 Number of operands  2

 Input data type  

Integer type, integer type

 Output data type  

Same as Inputs

 Examples  

OUT := MOD( 10, 3 ); (* OUT = 1 *)

 MUL 

 Description  

Arithmetic multiplication. Multiplies the two inputs.

 Number of operands  2

 Input data type  

Any numerical type, Any numerical type

LogicLab user manual 

185 MUL 

 Output data type  

Same as Inputs

 Examples  

OUT := MUL( 10, 10 ); (* OUT = 100 *)

 POW 

 Description  

Exponentiation. Raises Base to the power Expo

 Number of operands  2

 Input data type  

LREAL where available, REAL otherwise;

LREAL where available, REAL otherwise

 Output data type  

LREAL where available, REAL otherwise

 Examples  

OUT := POW( 2.0, 3.0 ); (* OUT = 8.0 *)

OUT := POW( -1.0, 5.0 ); (* OUT = -1.0 *)

 SIN 

 Description  

Sine. Computes the sine function of input #0 expressed in 

radians

 Number of operands  1

 Input data type  

LREAL where available, REAL otherwise

 Output data type  

LREAL where available, REAL otherwise

 Examples  

OUT := SIN( 0.0 ); (* OUT = 0.0 *)

OUT := SIN( 2.5 * 3.141592 ); (* OUT ~ 1.0 *)

 SINH\ *

 Description  

Hyperbolic sine. Computes the hyperbolic sine function of 

input #0

 Number of operands  1

 Input data type  

LREAL where available, REAL otherwise

 Output data type  

LREAL where available, REAL otherwise

 Examples  

OUT := SINH( 0.0 ); (* OUT = 0.0 *)

 SQRT 

 Description  

Square root. Computes the square root of input #0

 Number of operands  1

 Input data type  

LREAL where available, REAL otherwise

 Output data type  

LREAL where available, REAL otherwise

 Examples  

OUT := SQRT( 4.0 ); (* OUT = 2.0 *)

 SUB 

 Description  

Arithmetic subtraction. Subtracts input #1 from input #0

 Number of operands  2

 Input data type  

Any numerical type, Any numerical type

 Output data type  

Same as Inputs

 Examples  

OUT := SUB( 10, 3 ); (* OUT = 7 *)

186 

LogicLab user manual TAN 

 Description  

Tangent. Computes the tangent function of input #0 

expressed in radians

 Number of operands  1

 Input data type  

LREAL where available, REAL otherwise

 Output data type  

LREAL where available, REAL otherwise

 Examples  

OUT := TAN( 0.0 ); (* OUT = 0.0 *)

OUT := TAN( 3.141592 / 4.0 ); (* OUT ~ 1.0 *)

 TANH\ *

 Description  

Hyperbolic tangent. Computes the hyperbolic tangent 

function of input #0

 Number of operands  1

 Input data type  

LREAL where available, REAL otherwise

 Output data type  

LREAL where available, REAL otherwise

 Examples  

OUT := TANH( 0.0 ); (* OUT = 0.0 *)

*: function provided as extension to the IEC 61131-3 standard.

 Bit string functions 

 AND 

 Description  

Logical AND if both Input #0 and Input #1 are BOOL, 

otherwise bitwise AND.

 Number of operands  2

 Input data type  

Any but STRING, Any but STRING

 Output data type  

Same as Inputs

 Examples 

OUT := TRUE AND FALSE; (* OUT = FALSE *)

OUT := 16#1234 AND 16#5678; (* OUT = 16#1230 *)

 NOT 

 Description  

Logical NOT if Input is BOOL, otherwise bitwise NOT.

 Number of operands  1

 Input data type  

Any but STRING

 Output data type  

Same as Inputs

 Examples  

OUT := NOT FALSE; (* OUT = TRUE *)

OUT := NOT 16#1234;(* OUT = 16#EDCB *)

 OR 

 Description  

Logical OR if both Input #0 and Input #1 are BOOL, 

otherwise bitwise OR.

 Number of operands  2

 Input data type  

Any but STRING, Any but STRING

 Output data type  

Same as Inputs

LogicLab user manual 

187 OR 

 Examples  

OUT := TRUE OR FALSE; (* OUT = FALSE *)

OUT := 16#1234 OR 16#5678;(* OUT = 16#567C *)

 R 

 Description  

Reset operator: reset input to 0

 Number of operands  1

 Input data type  

BOOL

 Output data type  

Same as Input #0

 Examples 

 ROL 

 Description  

Input #0 left-shifted of Input #1 bits, circular.

 Number of operands  2

 Input data type  

Any numerical type, Any numerical type

 Output data type  

Same as Input #0

 Examples  

OUT := ROL( IN := 16#1000CAFE, 4 );

(* OUT = 16#000CAFE1 *)

 ROR 

 Description  

Input #0 right-shifted of Input #1 bits, circular.

 Number of operands  2

 Input data type  

Any numerical type, Any numerical type

 Output data type  

Same as Input #0

 Examples  

OUT := ROR( IN := 16#1000CAFE, 16 );

(* OUT = 16#CAFE1000 *)

 S 

 Description  

Set operator: set input to 1

 Number of operands  1

 Input data type  

BOOL

 Output data type  

Same as Input #0

 Examples 

 SHL 

 Description  

Input#0 left-shifted of Input #1 bits, zero filled on the right.

 Number of operands  2

 Input data type  

Any numerical type, Any numerical type

 Output data type  

Same as Input #0

 Examples  

OUT := SHL( IN := 16#1000CAFE, 16 );

(* OUT = 16#CAFE0000 *)

188 

LogicLab user manual SHR 

 Description  

Input #0 right-shifted of Input #1 bits, zero filled on the

left.

 Number of operands  2

 Input data type  

Any numerical type, Any numerical type

 Output data type  

Same as Input #0

 Examples  

OUT := SHR( IN := 16#1000CAFE, 24 );

(* OUT = 16#00000010 *)

 XOR 

 Description  

Logical XOR if both Input #0 and Input #1 are BOOL, 

otherwise bitwise XOR.

 Number of operands  2

 Input data type  

Any but STRING, Any but STRING

 Output data type  

Same as Inputs

 Examples  

OUT := TRUE OR FALSE; (* OUT = TRUE *)

OUT := 16#1234 OR 16#5678; (* OUT = 16#444C *)

 Selection functions 

 LIMIT 

 Description  

Limits Input #0 to be equal or more than Input#1, and 

equal or less than Input #2.

 Number of operands  3

 Input data type  

Any numerical type, Any numerical type, Any numerical type

 Output data type  

Same as Inputs

 Examples 

OUT := LIMIT( IN := 4, MN := 0, MX := 5 ); (* OUT = 

4 *)

OUT := LIMIT( IN := 88, MN := 0, MX := 5 );(* OUT = 

5 *)

OUT := LIMIT( IN := -1, MN := 0, MX := 5 );(* OUT = 

0 *)

 MAX 

 Description  

Maximum value selection

 Number of operands  2, extensible

 Input data type  

Any numerical type, Any numerical type, .., Any numerical 

type

 Output data type  

Same as max Input

 Examples  

OUT := MAX( -8, 120, -1000 ); (* OUT = 120 *)

 MIN 

 Description  

Minimum value selection

 Number of operands  2, extensible

LogicLab user manual 

189 MIN 

 Input data type  

Any numerical type, Any numerical type, .., Any numerical 

type

 Output data type  

Same as min Input

 Examples  

OUT := MIN( -8, 120, -1000 ); (* OUT = -1000 *)

 MUX 

 Description  

Multiplexer. Selects one of N inputs depending on input K

 Number of operands  3, extensible

 Input data type  

Any numerical type, Any numerical type, ..., Any numerical 

type

 Output data type  

Same as selected Input

 Examples  

OUT := MUX( 0, A, B, C ); (* OUT = A *)

 SEL 

 Description  

Binary selection

 Number of operands  3

 Input data type  

BOOL, Any, Any

 Output data type  

Same as selected Input

 Examples  

OUT := SEL( G := FALSE, IN0 := X, IN1 := 5 );

(* OUT = X *)

 Comparison functions 

Comparison functions can be also used to compare strings if this feature is supported by 

target device.

 EQ 

 Description  

Equal to. Returns TRUE if Input #0 = Input #1, otherwise 

FALSE.

 Number of operands  2

 Input data type  

Any, Any

 Output data type  

BOOL

 Examples  

OUT := EQ( TRUE, FALSE ); 

(* OUT = FALSE *)

OUT := EQ( ‘AZ’, ‘ABC’ ); (* OUT = FALSE *)

 GE 

 Description  

Greater than or equal to. Returns TRUE if Input #0 >= 

Input #1, otherwise FALSE.

 Number of operands  2

 Input data type  

Any but BOOL, Any but BOOL

 Output data type  

BOOL

 Examples  

OUT := GE( 20, 20 ); (* OUT = TRUE *)

OUT := GE( ‘AZ’, ‘ABC’ ); (* OUT = FALSE *)

190 

LogicLab user manual GT 

 Description  

Greater than. Returns TRUE if Input #0 > Input #1, 

otherwise FALSE.

 Number of operands  2

 Input data type  

Any but BOOL, Any but BOOL

 Output data type  

BOOL

 Examples  

OUT := GT( 0, 20 ); (* OUT = FALSE *)

OUT := GT( ‘AZ’, ‘ABC’ ); (* OUT = TRUE *)

 LE 

 Description  

Less than or equal to. Returns TRUE if Input #0 <= Input 

\#1, otherwise FALSE.

 Number of operands  2

 Input data type  

Any but BOOL, Any but BOOL

 Output data type  

BOOL

 Examples  

OUT := LE( 20, 20 ); (* OUT = TRUE *)

OUT := LE( ‘AZ’, ‘ABC’ ); (* OUT = FALSE *)

 LT 

 Description  

Less than. Returns TRUE if Input #0 < Input #1, otherwise 

FALSE.

 Number of operands  2

 Input data type  

Any but BOOL, Any but BOOL

 Output data type  

BOOL

 Examples  

OUT := LT( 0, 20 ); (* OUT = TRUE *)

OUT := LT( ‘AZ’, ‘ABC’ ); (* OUT = FALSE *)

 NE 

 Description  

Not equal to. Returns TRUE if Input #0 != Input #1, 

otherwise FALSE.

 Number of operands  2

 Input data type  

Any, Any

 Output data type  

BOOL

 Examples  

OUT := NE( TRUE, FALSE ); (* OUT = TRUE *)

OUT := NE( ‘AZ’, ‘ABC’ ); (* OUT = TRUE *)

 String functions 

The availability of the following functions depends on the target device. Please refer to 

your hardware supplier for details.

 CONCAT 

 Description  

Character string concatenation

 Number of operands  2

 Input data type  

STRING, STRING

 Output data type  

STRING

LogicLab user manual 

191 CONCAT 

 Examples  

OUT := CONCAT( ‘AB’, ‘CD’ ); (* OUT = ‘ABCD’ *)

 DELETE 

 Description  

Delete L characters of IN, beginning at the P-th character 

position

 Number of operands  3

 Input data type  

STRING, UINT, UINT

 Output data type  

STRING

 Examples  

OUT := DELETE( IN := ‘ABXYC’, L := 2, P := 3 ); 

(* OUT = ‘ABC’ *)

 FIND 

 Description 

Find the character position of the beginning of the first

occurrence of IN2 in IN1. If no occurrence of IN2 is found, 

then OUT := 0.

 Number of operands  2

 Input data type  

STRING, STRING

 Output data type  

UINT

 Examples  

OUT := FIND( IN1 := ‘ABCBC’, IN2 := ‘BC’ ); (* OUT 

= 2 *)

 INSERT 

 Description  

Insert IN2 into IN1 after the P-th character position

 Number of operands  3

 Input data type  

STRING, STRING, UINT

 Output data type  

STRING

 Examples  

OUT := INSERT( IN1 := ‘ABC’, IN2 := ‘XY’, P := 2 );

(* OUT = ‘ABXYC’ *)

 LEFT 

 Description  

Leftmost L characters of IN

 Number of operands  2

 Input data type  

STRING, UINT

 Output data type  

STRING

 Examples  

OUT := LEFT( IN := ‘ASTR’, L := 3 ); (* OUT = ‘AST’ 

*)

 LEN 

 Description  

Return the length of a string

 Number of operands  1

 Input data type  

STRING

 Output data type  

UINT

 Examples  

OUT := LEN( ‘ASTRING’ ); (* OUT = 7 *)

192 

LogicLab user manual MID 

 Description  

L characters of IN, beginning at the P-th

 Number of operands  3

 Input data type  

STRING, UINT, UINT

 Output data type  

STRING

 Examples  

OUT := MID( IN := ‘ASTR’, L := 2, P := 2 ); 

(* OUT = ‘ST’ *)

 REPLACE 

 Description  

Replace L characters of IN1 by IN2, starting at the P-th 

character position

 Number of operands  4

 Input data type  

STRING, STRING, UINT, UINT

 Output data type  

STRING

 Examples  

OUT := REPLACE( IN1 := ‘ABCDE’, IN2 := ‘X’, L := 2, 

P := 3 ); (* OUT = ‘ABXE’ *)

 RIGHT 

 Description  

Rightmost L characters of IN

 Number of operands  2

 Input data type  

STRING, UINT

 Output data type  

STRING

 Examples  

OUT := RIGHT( IN := ‘ASTR’, L := 3 ); (* OUT = 

‘STR’ *)

 TO_STRINGFORMAT 

 Description  

Conversion to STRING, with format specifier

 Number of operands  2

 Input data type  

Any numerical type, STRING

 Output data type  

STRING

 Examples  

str := TO_STRINGFORMAT(10, ‘%04d’); (* str = ‘0010’ 

*)

 TO_WSTRINGFORMAT 

 Description  

Conversion to WSTRING, with format specifier

 Number of operands  2

 Input data type  

Any numerical type, WSTRING

 Output data type  

WSTRING

 Examples  

wstr := TO_WSTRINGFORMAT(10, ‘%04d’); (* wstr = 

“0010” *)

 Standard operator 

LogicLab user manual 

193 ADR 

 Description  

Return the address of a variable

 Number of operands  1

 Input data type  

Any

 Output data type  

DWORD

 Examples 

 IMOVE 

 Description 

Valorize an interface using another interface and executing 

a query interface; checking if the class that implement 

the source interface is also implementing the destination 

interface 

 Number of operands  1

 Input data type  

Interface instance

 Output data type  

NULL if error, any if ok

 Examples 

 JMP 

 Description  

Jump to a specific label

 Number of operands  1

 Input data type  

STRING

 Output data type 

 Examples 

 MOVE 

 Description  

Assign a value to a variable, equivalent of LD and ST

 Number of operands  2

 Input data type  

Any, Any

 Output data type 

 Examples 

 REF 

 Description  

Return the reference to a variable

 Number of operands  1

 Input data type  

Any

 Output data type  

Reference to the input variable

 Examples 

 RET 

 Description  

Return

 Number of operands  0

 Input data type 

 Output data type 

 Examples 

194 

LogicLab user manual SIZEOF 

 Description  

Return the size of a variable

 Number of operands  1

 Input data type  

Any

 Output data type  

UDINT

 Examples 

 Date functions 

 CONCAT_DATE 

 Description  

Create a valid DATE value given its single components (year, 

month and day).

 Number of operands  3

 Input data type  

INT, INT, INT

 Output data type  

DATE

 Examples  

out := CONCAT_DATE(2020, 6, 17); (* out = 2020-06-

17 *)

 CONCAT_DATE_LTOD 

 Description  

Concatenate a DATE and a LTIME_OF_DAY into a LDATE_

AND_TIME

 Number of operands  2

 Input data type  

DATE, LTIME_OF_DAY

 Output data type  

LDATE_AND_TIME

 Examples 

out := CONCAT_DATE_LTOD(2020-06-17, 

13:40:55.123456789); (* out = 2020-06-17-

13:40:55.123456789 *)

 CONCAT_DATE_TOD 

 Description  

Concatenate a DATE and a TIME_OF_DAY into a DATE_AND_

TIME

 Number of operands  2

 Input data type  

DATE, TIME_OF_DAY

 Output data type  

DATE_AND_TIME

 Examples  

out := CONCAT_DATE_TOD(2020-06-17, 13:40:55.123); 

(* out = 2020-06-17-13:40:55.123 *)

 CONCAT_DT 

 Description  

Create a valid DATE_AND_TIME value given its single 

components (year, month, day, hours, minutes, seconds).

 Number of operands  2

 Input data type  

INT, INT, INT, INT, INT, INT

 Output data type  

DATE_AND_TIME

 Examples  

out := CONCAT_DT(2020, 6, 17, 13, 40, 55); (* out = 

2020-06-17-13:40:55 *)

LogicLab user manual 

195 CONCAT_LDATE 

 Description  

Create a valid LDATE value given its single components 

(year, month and day).

 Number of operands  3

 Input data type  

INT, INT, INT

 Output data type  

LDATE

 Examples  

out := CONCAT_LDATE(2020, 6, 17); (* out = 2020-06-

17 *)

 CONCAT_LDT 

 Description 

Create a valid LDATE_AND_TIME value given its single 

components (year, month, day, hours, minutes, seconds, 

milliseconds, microseconds, nanoseconds).

 Number of operands  9

 Input data type  

INT, INT, INT, INT, INT, INT, INT, INT, INT

 Output data type  

LDATE_AND_TIME

 Examples 

out := CONCAT_LDATE_AND_TIME(2020, 6, 17, 13, 40, 

55, 123, 456, 789); 

(* out = 2020-06-17-13:40:55.123456789 *)

 CONCAT_LTOD 

 Description 

Create a valid LTIME_OF_DAY value given its single 

components (hours, minutes, seconds, milliseconds, 

microseconds and nanoseconds).

 Number of operands  6

 Input data type  

INT, INT, INT, INT, INT, INT

 Output data type  

LTIME_OF_DAY

 Examples  

out := CONCAT_LTOD(13, 40, 55, 123, 456, 789); (* 

out = 13:40:55.123456789 *)

 CONCAT_TOD 

 Description  

Create a valid TIME_OF_DAY value given its single 

components (hours, minutes, seconds, milliseconds).

 Number of operands  4

 Input data type  

INT, INT, INT, INT

 Output data type  

TIME_OF_DAY

 Examples  

out := CONCAT_TOD(13, 40, 55, 123); (* out = 

13:40:55.123 *)

 DAY_OF_WEEK 

 Description 

Get the day of week. 

It returns the day of the week represented in a range from 0 

(Sunday) to 6 (Saturday).

 Number of operands  1

 Input data type  

LDATE

 Output data type  

SINT

 Examples  

out := DAY_OF_WEEK(2020-06-17); (* out = 3 *)

196 

LogicLab user manual SPLIT_DATE 

 Description  

Split a LDATE into year, month and day integer pointer 

vabiables. The function returns TRUE in case of no errors.

 Number of operands  4

 Input data type  

DATE/LDATE, @INT, @INT, @INT

 Output data type  

BOOL

 Examples 

 SPLIT_DT 

 Description 

Split a DATE_AND_TIME into year, month, day, hours, 

minutes and seconds integer pointer vabiables. The function 

returns TRUE in case of no errors.

 Number of operands  7

 Input data type  

DATE_AND_TIME, @INT, @INT, @INT, @INT, @INT, @INT

 Output data type  

BOOL

 Examples 

 SPLIT_LDT 

 Description 

Split a LDATE_AND_TIME into year, month, day, hours, 

minutes, seconds, milliseconds, microseconds and 

nanosecods integer pointer vabiables. The function returns 

TRUE in case of no errors.

 Number of operands  10

 Input data type  

DATE_AND_TIME, @INT, @INT, @INT, @INT, @INT, @INT, @

INT, @INT, @INT

 Output data type  

BOOL

 Examples 

 SPLIT_LTOD 

 Description 

Split a LTIME_OF_DAY into hours, minutes, seconds, 

milliseconds, microseconds and nanoseconds integer pointer 

vabiables. The function returns TRUE in case of no errors.

 Number of operands  7

 Input data type  

LTIME_OF_DAY, @INT, @INT, @INT, @INT, @INT, @INT

 Output data type  

BOOL

 Examples 

 SPLIT_TOD 

 Description 

Split a TIME_OF_DAY into hours, minutes, seconds, 

milliseconds integer pointer vabiables. The function returns 

TRUE in case of no errors.

 Number of operands  5

 Input data type  

TIME_OF_DAY, @INT, @INT, @INT, @INT

 Output data type  

BOOL

 Examples 

LogicLab user manual 

197 
### 11.2 INSTRUCTION LIST (IL) 

This section defines the semantics of the IL (Instruction List) language.

#### 11.2.1 SYNTAX AND SEMANTICS 

#### 11.2.1.1 SYNTAX OF IL INSTRUCTIONS 

IL code is composed of a sequence of instructions. Each instruction begins on a new line 

and contains an operator with optional modifiers, and, if necessary for the particular op

eration, one or more operands separated by commas. Operands can be any of the data 

representations for literals and for variables.

The instruction can be preceded by an identifying label followed by a colon (:). Empty 

lines can be inserted between instructions.

 Example 

Let us parse a small piece of code:

START:

LD %IX1 (* Push button *) 

ANDN %MX5.4 (* Not inhibited *)		

ST %QX2 (* Fan out *)

The elements making up each instruction are classified as follows:

 Label  

 Operator  

 [+ modifier]  

 Operand  

 Comment 

START: 

LD 

%IX1 

(* Push button *)

ANDN 

%MX5.4 

(* Not inhibited *)

ST 

%QX2 

(* Fan out *)

 Semantics of IL instructions 

\- Accumulator

By accumulator a register is meant containing the value of the currently evaluated re

sult.

\- Operators

Unless otherwise specified, the semantics of the operators is

accumulator := accumulator OP operand

That is, the value of the accumulator is replaced by the result yielded by operation OP 

applied to the current value of the accumulator itself, with respect to the operand. For 

instance, the instruction “AND %IX1” is interpreted as

accumulator := accumulator AND %IX1

and the instruction “GT %IW10” will have the Boolean result TRUE if the current value 

of the accumulator is greater than the value of input word 10, and the Boolean result 

FALSE otherwise:

accumulator := accumulator GT %IW10

\- Modifiers

The modifier “N” indicates bitwise negation of the operand.

The left parenthesis modifier “(” indicates that evaluation of the operator must be de

ferred until a right parenthesis operator “)” is encountered. The form of a parenthesized 

sequence of instructions is shown below, referred to the instruction

accumulator := accumulator AND (%MX1.3 OR %MX1.4)

198 

LogicLab user manualThe modifier “C” indicates that the associated instruction can be performed only if the 

value of the currently evaluated result is Boolean 1 (or Boolean 0 if the operator is com

bined with the “N” modifier).

#### 11.2.2 STANDARD OPERATORS 

Standard operators with their allowed modifiers and operands are as listed below.

 Operator   Modifiers 

 Supported operand  

 types: Acc_type,  

 Op_type 

 Semantics 

LD 

N 

Any, Any 

Sets the accumulator equal to 

operand.

ST 

N 

Any, Any 

Stores the accumulator into 

operand location.

S 

BOOL, BOOL 

Sets operand to TRUE if 

accumulator is TRUE. 

R 

BOOL, BOOL 

Sets operand to FALSE if 

accumulator is TRUE.

AND 

N, ( 

Any but REAL, Any but 

REAL 

Logical or bitwise AND

OR 

N, ( 

Any but REAL, Any but 

REAL 

Logical or bitwise OR

XOR 

N, ( 

Any but REAL, Any but 

REAL 

Logical or bitwise XOR

NOT 

Any but REAL 

Logical or bitwise NOT

ADD 

( 

Any but BOOL 

Addition

SUB 

( 

Any but BOOL 

Subtraction 

MUL 

( 

Any but BOOL 

Multiplication 

DIV 

( 

Any but BOOL 

Division

MOD 

( 

Any but BOOL 

Modulo-division 

GT 

( 

Any but BOOL 

Comparison:

GE 

( 

Any but BOOL 

Comparison: = 

EQ 

( 

Any but BOOL 

Comparison: = 

NE 

( 

Any but BOOL 

Comparison: 

LE 

( 

Any but BOOL 

Comparison:

LT 

( 

Any but BOOL 

Comparison: 

JMP 

C, N 

Label 

Jumps to label 

CAL 

C, N 

FB instance name 

Calls function block 

RET 

C, N 

Returns from called program, 

function, or function block.

) 

Evaluates deferred operation.

LogicLab user manual 

199 
#### 11.2.3 CALLING FUNCTIONS AND FUNCTION BLOCKS 

##### 11.2.3.1 CALLING FUNCTIONS 

Functions (as defined in the relevant section) are invoked by placing the function name in

the operator field. This invocation takes the following form:

LD 1

MUX 5, var0, -6.5, 3.14

ST vRES

Note that the first argument is not contained in the input list, but the accumulator is used

as the first argument of the function. Additional arguments (starting with the 2nd), if re

quired, are given in the operand field, separated by commas, in the order of their decla

ration. For example, operator MUX in the table above takes 5 operands, the first of which

is loaded into the accumulator, whereas the remaining 4 arguments are orderly reported 

after the function name.

 The following rules apply to function invocation. 

1) Assignments to VAR_INPUT arguments may be empty, constants, or variables.

2) Execution of a function ends upon reaching a RET instruction or the physical end of 

the function. When this happens, the output variable of the function is copied into the 

accumulator.

 Calling Function Blocks 

Function blocks (as defined in the relevant section) can be invoked conditionally and un

conditionally via the CAL operator. This invocation takes the following form:

LD A

ADD 5

ST INST5.IN1

LD 3.141592

ST INST5.IN2

CAL INST5

LD INST5.OUT1

ST vRES

LD INST5.OUT2

ST vVALID

This method of invocation is equivalent to a CAL with an argument list, which contains only 

one variable with the name of the FB instance.

Input arguments are passed to / output arguments are read from the FB instance through 

ST / LD operations performed on operands taking the following form:

FBInstanceName.IO_var

where

 Keyword  

 Description 

FBInstanceName Name of the instance to be invoked.

IO_var 

Input or output variable to be written / read.

 ### 11.3 FUNCTION BLOCK DIAGRAM (FBD) 

This section defines the semantics of the FBD (Function Block Diagram) language.

200 

LogicLab user manual
#### 11.3.1 REPRESENTATION OF LINES AND BLOCKS 

The graphic language elements are drawn using graphic or semi graphic elements, as 

shown in the table below.

No storage of data or association with data elements can be associated with the use of 

connectors; hence, to avoid ambiguity, connectors cannot be given any identifier.

 Feature  

 Example 

Lines

 

Line crossing with connection

Blocks with connecting lines 

and unconnected pins

#### 11.3.2 DIRECTION OF FLOW IN NETWORKS 

A network is defined as a maximal set of interconnected graphic elements. A network

label delimited on the right by a colon (:) can be associated with each network or group 

of networks. The scope of a network and its label is local to the program organization unit 

(POU) where the network is located.

Graphic languages are used to represent the flow of a conceptual quantity through one

or more networks representing a control plan. Namely, in the case of function block dia

grams (FBD), the “Signal flow” is typically used, analogous to the flow of signals between

elements of a signal processing system. Signal flow in the FBD language is from the out

put (right-hand) side of a function or function block to the input (left-hand) side of the 

function or function block(s) so connected.

#### 11.3.3 EVALUATION OF NETWORKS 

##### 11.3.3.1 ORDER OF EVALUATION OF NETWORKS 

The order in which networks and their elements are evaluated is not necessarily the same 

as the order in which they are labeled or displayed. When the body of a program organiza

tion unit (POU) consists of one or more networks, the results of network evaluation within 

the aforesaid body are functionally equivalent to the observance of the following rules:

1) No element of a network is evaluated until the states of all of its inputs have been 

evaluated.

2) The evaluation of a network element is not complete until the states of all of its out

puts have been evaluated.

3) As stated when describing the FBD editor, a network number is automatically as

signed to every network. Within a program organization unit (POU), networks are 

evaluated according to the sequence of their number: network N is evaluated before 

network N+1, unless otherwise specified by means of the execution control elements.

LogicLab user manual 

201
##### 11.3.3.2 COMBINATION OF ELEMENTS 

Elements of the FBD language must be interconnected by signal flow lines.

Outputs of blocks shall not be connected together. In particular, the “wired-OR” construct 

of the LD language is not allowed, as an explicit Boolean “OR” block is required.

 Feedback 

A feedback path is said to exist in a network when the output of a function or function 

block is used as the input to a function or function block which precedes it in the network; 

the associated variable is called a feedback variable.

Feedback paths can be utilized subject to the following rules:

1) Feedback variables must be initialized, and the initial value is used during the first

evaluation of the network. Look at the  Global variables  editor, the Local variables 

editor, or the Parameters editor to know how to initialize the respective item.

2) Once the element with a feedback variable as output has been evaluated, the new 

value of the feedback variable is used until the next evaluation of the element.

For instance, the Boolean variable RUN is the feedback variable in the example shown 

below.

 Explicit loop 

 Implicit loop 

#### 11.3.4 EXECUTION CONTROL ELEMENTS 

##### 11.3.4.1 EN/ENO SIGNALS 

Additional Boolean EN (Enable) input and ENO (Enable Out) characterize LogicLab blocks, 

according to the declarations

202 

LogicLab user manual EN  

 ENO 

VAR_INPUT

 EN: BOOL := 1;

END_VAR

VAR_OUTPUT

 ENO: BOOL;

END_VAR

See the  Modifying  properties of blocks section to know how to add these pins to a block.

 

When these variables are used, the execution of the operations defined by the block are

controlled according to the following rules:

1) If the value of EN is FALSE when the block is invoked, the operations defined by the

function body are not executed and the value of ENO is reset to FALSE by the program

mable controller system.

2) Otherwise, the value of ENO is set to TRUE by the programmable controller system, 

and the operations defined by the block body are executed.

##### 11.3.4.2 JUMPS 

Jumps are represented by a Boolean signal line terminated in a double arrowhead. The 

signal line for a jump condition originates at a Boolean variable, or at a Boolean output of 

a function or function block. A transfer of program control to the designated network label 

occurs when the Boolean value of the signal line is TRUE; thus, the unconditional jump is 

a special case of the conditional jump.

The target of a jump is a network label within the program organization unit within which 

the jump occurs.

 Symbol / Example  

 Explanation 

Unconditional Jump

Conditional Jump

Example: Jump Condition 

Network

LogicLab user manual 

203
##### 11.3.4.3 CONDITIONAL RETURNS 

\- Conditional returns from functions and function blocks are implemented using a RETURN

construction as shown in the table below. Program execution is transferred back to the 

invoking entity when the Boolean input is TRUE, and continues in the normal fashion 

when the Boolean input is FALSE. 

\- Unconditional returns are provided by the physical end of the function or function block.

 Symbol / Example  

 Explanation 

Conditional Return

Example: Return Condition 

Network

### 11.4 LADDER DIAGRAM (LD) 

This section defines the semantics of the LD (Ladder Diagram) language.

#### 11.4.1 POWER RAILS 

The LD network is delimited on the left side by a vertical line known as the left power rail, 

and on the right side by a vertical line known as the right power rail. The right power rail 

may be explicit in the LogicLab implementation and it is always shown.

The two power rails are always connected with an horizontal line named signal link. All LD 

elements should be placed and connected to the signal link.

 Description  

 Symbol 

Left power rail (with attached 

horizontal link)

Right power rail (with attached 

horizontal link)

Power rails connected by the 

signal link

204 

LogicLab user manual 11.4.2 LINK ELEMENTS AND STATES 

Link elements may be horizontal or vertical. The state of the link elements shall be de

noted “ON” or “OFF”, corresponding to the literal Boolean values 1 or 0, respectively. The 

term link state shall be synonymous with the term power flow.

The following properties apply to the link elements:

\- The state of the left rail shall be considered ON at all times. No state is defined for the

right rail.

\- A horizontal link element is indicated by a horizontal line. A horizontal link element 

transmits the state of the element on its immediate left to the element on its immedi

ate right.

\- The vertical link element consists of a vertical line intersecting with one or more hori

zontal link elements on each side. The state of the vertical link represents the inclusive 

OR of the ON states of the horizontal links on its left side, that is, the state of the verti

cal link is:

OFF if the states of all the attached horizontal links to its left are OFF;

ON if the state of one or more of the attached horizontal links to its left is ON. 

\- The state of the vertical link is copied to all of the attached horizontal links on its right.

\- The state of the vertical link is not copied to any of the attached horizontal links on its 

left.

 Description  

 Symbol 

Vertical link with attached 

horizontal links

 11.4.3 CONTACTS 

A contact is an element which imparts a state to the horizontal link on its right side which 

is equal to the Boolean AND of the state of the horizontal link at its left side with an ap

propriate function of an associated Boolean input, output, or memory variable.

A contact does not modify the value of the associated Boolean variable. Standard contact 

symbols are given in the following table.

 Name  

 Description  

 Symbol 

Normally open 

contact

The state of the left link is copied 

to the right link if the state of the 

associated Boolean variable is ON. 

Otherwise, the state of the right 

link is OFF.

Normally closed 

contact

The state of the left link is copied 

to the right link if the state of the 

associated Boolean variable is OFF. 

Otherwise, the state of the right 

link is OFF.

LogicLab user manual 

205 Name  

 Description  

 Symbol 

Positive transition

sensing contact

The state of the right link is 

ON from one evaluation of 

this element to the next when 

a transition of the associated 

variable from OFF to ON is sensed 

at the same time that the state of 

the left link is ON. The state of the 

right link shall be OFF at all other 

times.

Negative transition

sensing contact

The state of the right link is 

ON from one evaluation of 

this element to the next when 

a transition of the associated 

variable from ON to OFF is sensed 

at the same time that the state of 

the left link is ON. The state of the 

right link shall be OFF at all other 

times.

#### 11.4.4 COILS 

A coil copies the state of the link on its left side to the link on its right side without modi

fication, and stores an appropriate function of the state or transition of the left link into

the associated Boolean variable.

Standard coil symbols are shown in the following table.

 Name  

 Description  

 Symbol 

Coil

The state of the left link is 

copied to the associated 

Boolean variable.

Negated coil

The inverse of the state of 

the left link is copied to the 

associated Boolean variable, 

that is, if the state of the left 

link is OFF, then the state of the 

associated variable is ON, and 

vice versa.

SET (latch) coil

The associated Boolean variable 

is set to the ON state when the 

left link is in the ON state, and 

remains set until reset by a 

RESET coil.

RESET (unlatch) coil

The associated Boolean variable 

is reset to the OFF state when 

the left link is in the ON state, 

and remains reset until set by a 

SET coil.

Positive transition

sensing coil

The state of the associated 

Boolean variable is ON from 

one evaluation of this element 

to the next when a transition of 

the left link from OFF to ON is 

sensed.

206 

LogicLab user manual Name  

 Description  

 Symbol 

Negative transition

sensing coil

The state of the associated 

Boolean variable is ON from 

one evaluation of this element 

to the next when a transition of 

the left link from ON to OFF is 

sensed.

#### 11.4.5 OPERATORS, FUNCTIONS AND FUNCTION BLOCKS 

The representation of functions and function blocks in the LD language is similar to the 

one used for FBD. At least one Boolean input and one Boolean output shall be shown on 

each block to allow for power flow through the block as shown in the following figure.

### 11.5 STRUCTURED TEXT (ST) 

This section defines the semantics of the ST (Structured Text) language.

#### 11.5.1 EXPRESSIONS 

An expression is a construct which, when evaluated, yields a value corresponding to one 

of the data types listed in the elementary data types table. LogicLab does not set any 

constraint on the maximum length of expressions. 

Expressions are composed of operators and operands.

##### 11.5.1.1 OPERANDS 

An operand can be a literal, a variable, a function invocation, or another expression.

##### 11.5.1.2 OPERATORS 

Open the table of operators to see the list of all the operators supported by ST. The evalu

ation of an expression consists of applying the operators to the operands in a sequence 

defined by the operator precedence rules.

##### 11.5.1.3 OPERATOR PRECEDENCE RULES 

Operators have different levels of precedence, as specified in the table of operators. The

operator with highest precedence in an expression is applied first, followed by the opera

tor of next lower precedence, etc., until evaluation is complete. Operators of equal prec

edence are applied as written in the expression from left to right.

For example if A, B, C, and D are of type INT with values 1, 2, 3, and 4, respectively, then:

A+B-C*ABS(D)

yields -9, and:

(A+B-C)*ABS(D)

LogicLab user manual 

207yields 0.

When an operator has two operands, the leftmost operand is evaluated first. For example,

in the expression

SIN(A)*COS(B)

the expression SIN(A) is evaluated first, followed by COS(B), followed by evaluation of 

the product.

Functions are invoked as elements of expressions consisting of the function name fol

lowed by a parenthesized list of arguments, as defined in the relevant section.

 11.5.1.4 OPERATORS OF THE ST LANGUAGE 

 Operation  

 Symbol  

 Precedence 

Parenthesizing 

(<expression>) 

HIGHEST

.

.

.

.

.

.

.

.

.

.

.

.

.

Function evaluation 

<fname>(<arglist>)

Negation Complement - 

NOT

Exponentiation 

 

Multiply Divide Modulo

*

/

MOD

Add Subtract

+

\-

Comparison 

<, >, <=, >=

Equality Inequality 

=

<>

Boolean AND 

AND

Boolean Exclusive OR XOR

Boolean OR 

OR 

LOWEST

#### 11.5.2 STATEMENTS IN ST 

All statements comply with the following rules:

\- they are terminated by semicolons;

\- unlike IL, a carriage return or new line character is treated the same as a space char

acter; 

\- LogicLab does not set any constraint on the maximum length of statements.

ST statements can be divided into classes, according to their semantics.

##### 11.5.2.1 ASSIGNMENTS 

 Semantics 

The assignment statement replaces the current value of a single or multi-element variable 

by the result of evaluating an expression.

The assignment statement is also used to assign the value to be returned by a function, 

by placing the function name to the left of an assignment operator in the body of the 

function declaration. The value returned by the function is the result of the most recent 

evaluation of such an assignment.

208 

LogicLab user manual Syntax 

An assignment statement consists of a variable reference on the left-hand side, followed 

by the assignment operator “:=”, followed by the expression to be evaluated. For in

stance, the statement

A := B ;

would be used to replace the single data value of variable A by the current value of vari

able B if both were of type INT.

 Examples 

a := b ;

assignment

pCV := pCV + 1 ;

assignment

c := SIN( x );

assignment with function invocation

FUNCTION SIMPLE_FUN : REAL

variables declaration

...

function body

...

SIMPLE_FUN := a * b - c ;

END_FUNCTION

assigning the output value to a function

 11.5.2.2 FUNCTION AND FUNCTION BLOCK STATEMENTS 

 Semantics 

\- Functions are invoked as elements of expressions consisting of the function name fol

lowed by a parenthesized list of arguments. Each argument can be a literal, a variable, 

or an arbitrarily complex expression.

\- Function blocks are invoked by a statement consisting of the name of the function block 

instance followed by a parenthesized list of arguments. Both invocation with formal ar

gument list and with assignment of arguments are supported.

\- RETURN: function and function block control statements consist of the mechanisms for 

invoking function blocks and for returning control to the invoking entity before the phys

ical end of a function or function block. The RETURN statement provides early exit from 

a function or a function block (e.g., as the result of the evaluation of an IF statement).

 Syntax 

1) Function:

dst_var := function_name( arg1, arg2 , ... , argN );

2) Function block with formal argument list:

instance_name( 

var_in1 := arg1 ,

 

var_in2 := arg2 ,

 

... ,

 

var_inN := argN );

3) Function block with assignment of arguments:

instance_name.var_in1 := arg1;

...

instance_name.var_inN := argN;

LogicLab user manual 

209instance_name();

4) Function and function block control statement:

RETURN;

 Examples 

CMD_TMR( IN := %IX5,

 PT:= 300 ) ;

FB invocation with formal argument list:

IN := %IX5 ;

PT:= 300 ;

CMD_TMR() ;

FB invocation with assignment of arguments:

a := CMD_TMR.Q;

FB output usage:

RETURN ;

early exit from function or function block.

##### 11.5.2.3 SELECTION STATEMENTS 

 Semantics 

Selection statements include the IF and CASE statements. A selection statement selects 

one (or a group) of its component statements for execution based on a specified condi

tion.

\- IF: the IF statement specifies that a group of statements is to be executed only if the

associated Boolean expression evaluates to the value TRUE. If the condition is false, 

then either no statement is to be executed, or the statement group following the ELSE 

keyword (or the ELSIF keyword if its associated Boolean condition is true) is executed.

\- CASE: the CASE statement consists of an expression which evaluates to a variable of 

type DINT (the “selector”), and a list of statement groups, each group being labeled by 

one or more integer or ranges of integer values, as applicable. It specifies that the first

group of statements, one of whose ranges contains the computed value of the selector, 

is to be executed. If the value of the selector does not occur in a range of any case, the 

statement sequence following the keyword ELSE (if it occurs in the CASE statement) is 

executed. Otherwise, none of the statement sequences is executed. 

LogicLab does not set any constraint on the maximum allowed number of selections in 

CASE statements.

 Syntax 

Note that square brackets include optional code, while braces include repeatable portions 

of code. 

1) IF: 

IF expression1 THEN

stat_list

[ { ELSIF expression2 THEN

stat_list } ]

ELSE

stat_list 

END_IF ;

2) CASE: 

CASE expression1 OF

210 

LogicLab user manualintv [ {, intv } ] :

stat_list

{ intv [ {, intv } ] :

stat_list }

[ ELSE

stat_list ]

END_CASE ;

intv being either a constant or an interval: a or a..b

 Examples 

IF statement:

IF d 0.0 THEN

nRoots := 0 ;

ELSIF d = 0.0 THEN

nRoots := 1 ;

x1 := -b / (2.0 * a) ;

ELSE

nRoots := 2 ;

x1 := (-b + SQRT(d)) / (2.0 * a) ;

x2 := (-b - SQRT(d)) / (2.0 * a) ;

END_IF ;

CASE statement:

CASE tw OF

1, 5:

display := oven_temp ;

2:

display := motor_speed ;

3:

display := gross_tare;

4, 6..10:

display := status(tw - 4) ;

ELSE

 display := 0;

 tw_error := 1;

END_CASE ;

##### 11.5.2.4 ITERATION STATEMENTS 

 Semantics 

Iteration statements specify that the group of associated statements are executed repeat

edly. The FOR statement is used if the number of iterations can be determined in advance; 

otherwise, the WHILE or REPEAT constructs are used.

\- FOR: the FOR statement indicates that a statement sequence is repeatedly executed, 

up to the END_FOR keyword, while a progression of values is assigned to the FOR loop 

control variable. The control variable, initial value, and final value are expressions of

the same integer type (e.g., SINT, INT, or DINT) and cannot be altered by any of the 

repeated statements. The FOR statement increments the control variable up or down 

LogicLab user manual 

211from an initial value to a final value in increments determined by the value of an ex

pression; this value defaults to 1. The test for the termination condition is made at the 

beginning of each iteration, so that the statement sequence is not executed if the initial 

value exceeds the final value.

\- WHILE: the WHILE statement causes the sequence of statements up to the END_WHILE

keyword to be executed repeatedly until the associated Boolean expression is false. If 

the expression is initially false, then the group of statements is not executed at all.

\- REPEAT: the REPEAT statement causes the sequence of statements up to the UNTIL

keyword to be executed repeatedly (and at least once) until the associated Boolean 

condition is true.

\- EXIT: the EXIT statement is used to terminate iterations before the termination condi

tion is satisfied. When the EXIT statement is located within nested iterative constructs, 

exit is from the innermost loop in which the EXIT is located, that is, control passes to 

the next statement after the first loop terminator (END_FOR, END_WHILE, or END_RE

PEAT) following the EXIT statement.

Note: the WHILE and REPEAT statements cannot be used to achieve interprocess synchronization, 

for example as a “wait loop” with an externally determined termination condition. The SFC 

elements defined must be used for this purpose.

 Syntax 

Note that square brackets include optional code, while braces include repeatable portions 

of code. 

1) FOR: 

FOR control_var := init_val TO end_val [ BY increm_val ] DO

stat_list

END_FOR ;

2) WHILE: 

WHILE expression DO

stat_list

END_WHILE ;

3) REPEAT: 

REPEAT

stat_list

UNTIL expression

END_REPEAT ;

 Examples 

FOR statement:

j := 101 ;

FOR i := 1 TO 100 BY 2 DO

 IF arrvals[i] = 57 THEN

j := i ;

 EXIT ;

 END_IF ;

END_FOR ;

WHILE statement:

j := 1 ;

WHILE j <=100 AND arrvals[i] <> 57 DO

j := j + 2 ;

212 

LogicLab user manualEND_WHILE ;

REPEAT statement:

j := -1 ;

REPEAT

 j := j + 2 ;

UNTIL j = 101 AND arrvals[i] = 57

END_REPEAT ;

### 11.6 SEQUENTIAL FUNCTION CHART (SFC) 

This section defines Sequential Function Chart (SFC) elements to structure the internal

organization of a PLC program organization unit (POU), written in one of the languages 

defined in this standard, for the purpose of performing sequential control functions. The

definitions in this section are derived from IEC 848, with the necessary changes to convert

the representations from a standard documentation to a set of execution control elements 

for a PLC program organization unit.

Since SFC elements require storage of state information, the only program organization 

units which can be structured using these elements are function blocks and programs.

If any part of a program organization unit is partitioned into SFC elements, the entire 

program organization unit is so partitioned. If no SFC partitioning is given for a program 

organization unit, the entire program organization unit is considered to be a single action 

which executes under the control of the invoking entity.

 SFC elements 

The SFC elements provide a means of partitioning a PLC program organization unit into a 

set of steps and transitions interconnected by directed links. Associated with each step is 

a set of actions, and with each transition is associated a transition condition.

#### 11.6.1 STEPS 

##### 11.6.1.1 DEFINITION 

A step represents a situation where the behavior of a program organization unit (POU) 

with respect to its inputs and outputs follows a set of rules defined by the associated ac

tions of the step. A step is either active or inactive. At any given moment, the state of 

the program organization unit is defined by the set of active steps and the values of its

internal and output variables. 

A step is represented graphically by a block containing a step name in the form of an iden

tifier. The directed link(s) into the step can be represented graphically by a vertical line

attached to the top of the step. The directed link(s) out of the step can be represented by 

a vertical line attached to the bottom of the step.

 Representation  

 Description 

Step

(graphical representation with 

direct links)

LogicLab does not set any constraint on the maximum number of steps per SFC.

 Step flag 

The step flag (active or inactive state of a step) can be represented by the logic value of a

Boolean variable  *_x, where  * is the step name. This Boolean variable has the value 

TRUE when the corresponding step is active, and FALSE when it is inactive. The scope of 

LogicLab user manual 

213step names and step flags is local to the program organization unit where the steps ap

pear.

 Representation  

 Description 

Step Name_x

Step flag

= TRUE when Step Name_x is active 

= FALSE otherwise

##### 11.6.1.2 INITIAL STEP  

The initial state of the program organization unit is represented by the initial values of 

its internal and output variables, and by its set of initial steps, i.e., the steps which are 

initially active. Each SFC network, or its textual equivalent, has exactly one initial step. 

An initial step can be drawn graphically with double lines for the borders, as shown below. 

For system initialization, the default initial state is FALSE for ordinary steps and TRUE for 

initial steps. 

LogicLab cannot compile an SFC network not containing exactly one initial step. 

 Representation  

 Description 

Initial step

(graphical representation with 

direct links)

##### 11.6.1.3 ACTIONS  

An action can be: 

\- a collection of instructions in the IL language;

\- a collection of networks in the FBD language;

\- a collection of rungs in the LD language;

\- a collection of statements in the ST language;

\- a sequential function chart (SFC) organized as defined in this section.

Zero or more actions can be associated with each step. Actions are declared via one of the 

textual structuring elements listed in the following table.

 Structuring element  

 Description 

STEP StepName :

(* Step body *)

END_STEP

Step (textual form)

INITIAL_STEP StepName :

(* Step body *)

END_STEP

Initial step (textual form)

Such a structuring element exists in the  lsc  file for every step having at least one associ

ated action.

##### 11.6.1.4 ACTION QUALIFIERS 

The time when an action associated to a step is executed depends on its action qualifier.

LogicLab implements the following action qualifiers.

214 

LogicLab user manual Qualifier  

 Description  

 Meaning 

 N  

Non-stored (null qualifier). The action is executed as long as 

the step remains active.

 P  

Pulse.

The action is executed only once per 

step activation, regardless of the 

number of cycles the step remains 

active.

If a step has zero associated actions, then it is considered as having a  WAIT  function, that 

is, waiting for a successor transition condition to become true.

##### 11.6.1.5 JUMPS 

Direct links flow only downwards. Therefore, if you want to return to a upper step from a

lower one, you cannot draw a logical wire from the latter to the former. A special type of 

block exists, called Jump, which lets you implement such a transition.

A Jump block is logically equivalent to a step, as they have to always be separated by a 

transition. The only effect of a Jump is to activate the step flag of the preceding step and

to activate the flag of the step it points to.

 Representation  

 Description 

Jump 

(logical link to the destination step)

#### 11.6.2 TRANSITIONS 

##### 11.6.2.1 DEFINITION 

A transition represents the condition whereby control passes from one or more steps 

preceding the transition to one or more successor steps along the corresponding directed 

link. The transition is represented by a small grey square across the vertical directed link.

The direction of evolution following the directed links is from the bottom of the predeces

sor step(s) to the top of the successor step(s).

 11.6.2.2 TRANSITION CONDITION  

Each transition has an associated transition condition which is the result of the evaluation 

of a single Boolean expression. A transition condition which is always true is represented 

by the keyword TRUE, whereas a transition condition always false is symbolized by the 

keyword FALSE. 

A transition condition can be associated with a transition by one of the following means: 

 Representation  

 Description 

By placing the appropriate Boolean constant {TRUE, 

FALSE} adjacent to the vertical directed link.

By declaring a Boolean variable, whose value 

determines whether or not the transition is cleared.

LogicLab user manual 

215 Representation  

 Description 

By writing a piece of code, in any of the languages 

supported by LogicLab, except for SFC. The result 

of the evaluation of such a code determines the 

transition condition.

The scope of a transition name is local to the program organization unit (POU) where the 

transition is located.

#### 11.6.3 RULES OF EVOLUTION 

 Introduction 

The initial situation of a SFC network is characterized by the initial step which is in the 

active state upon initialization of the program or function block containing the network. 

Evolutions of the active states of steps take place along the directed links when caused by 

the clearing of one or more transitions.

A transition is enabled when all the preceding steps, connected to the corresponding tran

sition symbol by directed links, are active. The clearing of a transition occurs when the 

transition is enabled and when the associated transition condition is true. 

The clearing of a transition causes the deactivation (or “resetting”) of all the immediately 

preceding steps connected to the corresponding transition symbol by directed links, fol

lowed by the activation of all the immediately following steps. 

The alternation Step/Transition and Transition/Step is always maintained in SFC element 

connections, that is:

\- two steps are never directly linked; they are always separated by a transition;

\- two transitions are never directly linked; they are always separated by a step. 

When the clearing of a transition leads to the activation of several steps at the same time, 

the sequences which these steps belong to are called simultaneous sequences. After their 

simultaneous activation, the evolution of each of these sequences becomes independent. 

In order to emphasize the special nature of such constructs, the divergence and conver

gence of simultaneous sequences is indicated by a double horizontal line.

The clearing time of a transition may theoretically be considered as short as one may 

wish, but it can never be zero. In practice, the clearing time will be imposed by the PLC 

implementation: several transitions which can be cleared simultaneously will be cleared 

simultaneously, within the timing constraints of the particular PLC implementation and 

the priority constraints defined in the sequence evolution table. For the same reason, the

duration of a step activity can never be considered to be zero. Testing of the successor 

transition condition(s) of an active step shall not be performed until the effects of the step

activation have propagated throughout the program organization unit where the step is 

declared.

 Sequence evolution table 

This table defines the syntax and semantics of the allowed combinations of steps and

transitions.

216 

LogicLab user manual Example  

 Rule 

Normal transition

An evolution from step S3 to step S4

takes place if and only if step S3 is 

in the active state and the transition 

condition c is TRUE.

Divergent transition

An evolution takes place from S5 to 

S6 if and only if S5 is active and the 

transition condition e is TRUE, or from 

S5 to S8 only if S5 is active and f is 

TRUE and e is FALSE.

Convergent transition

An evolution takes place from S7

to S10 only if S7 is active and the 

transition condition h is TRUE, or from 

S9 to S10 only if S9 is active and j is 

TRUE.

Simultaneous divergent transition

An evolution takes place from S11 to

S12, S14,... only if S11 is active and 

the transition condition b associated 

to the common transition is TRUE. 

After the simultaneous activation of 

S12, S14, etc., the evolution of each 

sequence proceeds independently.

Simultaneous convergent transition

An evolution takes place from S13, 

S15,... to S16 only if all steps above 

and connected to the double horizontal 

line are active and the transition 

condition d associated to the common 

transition is TRUE.

 Examples 

LogicLab user manual 

217 Invalid scheme  

 Equivalent allowed scheme  

 Note 

Expected behavior: an 

evolution takes place 

from S30 to S33 if a is 

FALSE and d is TRUE.

The scheme in the 

leftmost column 

is invalid because 

conditions d and TRUE

are directly linked.

Expected behavior: an 

evolution takes place 

from S32 to S31 if c is 

FALSE and d is TRUE.

The scheme in the 

leftmost column 

is invalid because 

direct links flow only

downwards. Upward 

transitions can be 

performed via jump 

blocks.

#### 11.6.4 SFC CONTROL FLAGS 

LogicLab provides some control flags for SFC program or function blocks.

To enable this feature, please refer to paragraph 4.6.2.

Those flags are:

\- <POU name>_HOLD_SFC (type BOOL);

\- <POU name>_RESET_SFC (type BOOL).

Where <POU name> means the name of the SFC POU (program or function block).

For example, if the SFC POU is named Main, the control flags will be named Main_HOLD_

SFC and Main_RESET_SFC.

Another couple of actions is available for every SFC action, which also are contained in a 

SFC POU.

For example, if the above program  Main  contains a SFC action named  Execute , the con

trol flags of this action will be Main_Execute_HOLD_SFC and Main_Execute_RESET_SFC.

These flags functionalities are described in details on next paragraphs.

 11.6.4.1 HOLD FLAG 

Following the main characteristics of the <POU name>_HOLD_SFC flag:

\- default value is FALSE;

218 

LogicLab user manual- when set to TRUE, the SFC block, which is referred to ( the one with the same name as 

<POU name>), it is kept in the current status (hold) and no code is executed;

\- when the flag is set back to FALSE, the SFC block execution is recovered from exactly 

the same point in which was set to hold, trough <POU name>_HOLD_SFC := TRUE.

 11.6.4.2 RESET FLAG 

Following the main characteristics of the <POU name>_RESET_SFC flag:

\- default value is FALSE;

\- when set to TRUE, the SFC block, which is referred to (the one with the same name as 

<POU name>), it is brought back to the initial state, that is the execution state of the init 

action.

\- this is an auto-reset flag, which means that if it is set to TRUE his own state becomes 

FALSE after his reset action has been executed. It is therefore not necessary to bring 

the <POU name>_RESET_SFC value back to FALSE.

 11.6.4.3 FLAGS VISIBILITY 

The <POU name>_HOLD_SFC and <POU name>_RESET_SFC flags are automatically gener

ated from the code compiler and they belongs to the local variables of the POU which are 

referred to.

LogicLab does not show this flags in the variables list of the POU; they are hidden but in

any case they can be used everywhere within the code.

#### 11.6.5 CHECK A SFC POU FROM OTHER PROGRAMS 

To allow the managing of a SFC POU from other programs LogicLab provides the following 

functionalities:

\- The compiler automatically generates the <POU name>_RESET_SFC and <POU name>_

HOLD_SFC flags.

\- If the SFC POU is a function block, the user has the possibility to declare, as VAR_INPUT

and type BOOL, both flags having the name of the SFC POU control flags.

\- If the SFC POU is a program, the user has the possibility to declare, as VAR_GLOBAL and 

type BOOL, both flags having the name of the SFC POU control flags.

\- In both cases above, LogicLab compiler will use the variables declared among the VAR_

INPUT or VAR_GLOBAL ones and not those automatically generated (therefore they will 

be not generated).

Using these techniques, user then can manage the working state of the SFC POU from 

other POU using the INPUT variables of the SFC POU.

 Example 

FUNCTION_BLOCK test

VAR_INPUT

…

test_RESET_SFC : BOOL; (* Control flag explicitly declared *)

END_VAR

…

END_FUNCTION_BLOCK

PROGRAM Main

VAR

…

LogicLab user manual 

219block : test; (* SFC block instance *)

END_VAR

…

(* Reset SFC block state *)

block.test_RESET_SFC := TRUE;

…

END_PROGRAM

##### 11.6.5.1 SFC MACRO LIBRARY 

LogicLab makes available to user a library, called  SFCControl.pll , to allow the manage 

of the SFC states trough commands instead of variable settings.

This library is composed by macros usable only in ST language.

##### 11.6.5.2 USAGE EXAMPLE OF THE CONTROL FLAGS 

Following are some example of control flags usage, assuming the SFC POU is named Main:

\- Hold (freeze):

Main_HOLD_SFC := TRUE;

\- Restart from hold state:

Main_HOLD_SFC := FALSE;

\- Restart form initial state of a SFC block in hold state:

Main_RESET_SFC := TRUE;

Main_HOLD_SFC := FALSE;

\- Reset to initial state and instant restart of SFC block:

Main_RESET_SFC := TRUE; (* automatic reset from compiler *).

### 11.7 LOGICLAB LANGUAGE EXTENSIONS 

LogicLab features a few extensions to the IEC 61131-3 standard, in order to further enrich 

the language and to adapt to different coding styles.

#### 11.7.1 MACROS 

LogicLab implements macros in the same way a C programming language pre-processor 

does.

Macros can be defined using the following syntax:

MACRO <macro name>

 PAR_MACRO 		

<parameter list>

 END_PAR 	

<macro body>

END_MACRO

Note that the parameter list may eventually be empty, thus distinguishing between ob

ject-like macros, which do not take parameters, and function-like macros, which do take 

parameters.

A concrete example of macro definition is the following, which takes two bytes and com

poses a 16-bit word:

220 

LogicLab user manualMACRO MAKEWORD

PAR_MACRO 	

lobyte; 	

hibyte;

END_PAR

{ CODE:ST }

lobyte + SHL( TO_UINT( hibyte ), 8 )

END_MACRO

Whenever the macro name appears in the source code, it is replaced (along with the ac

tual parameter list, in case of function-like macros) with the macro body. For example, 

given the definition of the macro MAKEWORD and the following Structured Text code frag

ment:

w := MAKEWORD( b1, b2 );

the macro pre-processor expands it to

w := b1 + SHL( TO_UINT( b2 ), 8 );

#### 11.7.2 POINTERS 

Pointers are a special kind of variables which act as a reference to another variable (the 

pointed variable). The value of a pointer is, in fact, the address of the pointed variable; in 

order to access the data stored at the address pointed to, pointers can be dereferenced.

Pointer declaration requires the same syntax used in variable declaration, where the type 

name is the type name of the pointed variable preceded by a @ sign:

VAR 	

<pointer name> : @<pointed variable type name>;

END_VAR

For example, the declaration of a pointer to a REAL variable shall be as follows:

VAR

 px : @REAL;

END_VAR

A pointer can be assigned with another pointer or with an address. A special operator, ADR, 

is available to retrieve the address of a variable.

px := py;		

(* px and py are pointers to REAL (that is, vari

ables of type @REAL) *)

px := ADR( x ) 

(* x is a variable of type REAL *)

px := ?x		

(* ? is an alternative notation for ADR *)

The @ operator is used to dereference a pointer, hence to access the pointed variable.

px := ADR( x );

@px := 3.141592; (* the approximate value of pi is assigned to x *)

 pn := ADR( n );

n := @pn + 1;		

(* n is incremented by 1 *)

Beware that careless use of pointers is potentially dangerous: indeed, pointers can point 

to any arbitrary location, which can cause undesirable effects.

LogicLab user manual 

221
#### 11.7.3  WAITING STATEMENT 

LogicLab implements a  WAITING  statement that can be used in ST code as following ex

ample:

...

WAITING 

<condition> DO 		

<code to be executed waiting for condition becomes true>

END_WAITING;

...

Until the condition is not verified, the code will be executed (not as in a loop cycle but

returning to caller in every execution).

The  WAITING  statement can be used only if the associated project option is enabled (see 

paragraph 4.6.2 for more details).

222 

LogicLab user manual
