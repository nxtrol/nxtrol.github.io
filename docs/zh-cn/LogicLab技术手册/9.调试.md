## 9. DEBUGGING 

LogicLab provides several debugging tools, which help the developer to check whether the 

application behaves as expected or not.

All these debugging tools basically allow the developer to watch the value of selected vari

ables while the PLC application is running.

LogicLab debugging tools can be gathered in two classes:

\- Asynchronous debuggers. They read the values of the variables selected by the devel

oper with successive queries issued to the target device. Both the manager of the de

bugging tool (that runs on the PC) and, potentially, the task which is responsible to an

swer those queries (on the target device) run independently from the PLC application. 

Thus, there is no guarantee about the values of two distinct variables being sampled in 

the same moment, with respect to the PLC application execution (one or more cycles 

may have occurred); for the same reason, the evolution of the value of a single variable 

is not reliable, especially when it changes fast.

\- Synchronous debuggers. They require the definition of a trigger in the PLC code. They

refresh simultaneously all the variables they have been assigned every time the proces

sor reaches the trigger, as no further instruction can be executed until the value of all 

the variables is refreshed. As a result, synchronous debuggers obviate the limitations 

affecting asynchronous ones.

This chapter shows you how to debug your application using both asynchronous and syn

chronous tools.

### 9.1 WATCH WINDOW 

The *Watch* window allows you to monitor the current values of a set of variables. Being 

an asynchronous tool, the *Watch* window does not guarantee synchronization of values. 

Therefore, when reading the values of the variables in the *Watch* window, be aware of 

the possibility that they may refer to different execution cycles of the corresponding task.

The *Watch* window contains an item for each variable that you added to it. The informa

tion shown in the *Watch* window includes the name of the variable, its value, its type, and 

its location in the PLC application.

LogicLab user manual 

101
#### 9.1.1 OPENING AND CLOSING THE WATCH WINDOW 

To open, close the *Watch* window, click *View>Tool windows>Watch* .

Closing the *Watch* window means simply hiding it, not resetting it. As a matter of fact, if 

you close the *Watch* window and then open it again, you will see that it still contains all 

the variables you added to it.

##### 9.1.1.1 WATCH VARIABLES EDITOR 

A particular implementation of the watch window is available from the variables editor 

(both global and local); on the right side of the variables editor youâ€™ll see three tabs:

The third one, when pressed, will turn the variables editor into a watch window, where 

all the variables of the editor are already added to the list and their values are shown:

No other variables can be added to this list and the variables in this list cannot be re

moved.

#### 9.1.2 ADDING ITEMS TO THE WATCH WINDOW 

To watch a variable, you need to add it to the watch list.

Note that, unlike trigger windows and the *Graphic trigger* window, you can add to the 

*Watch* window all the variables of the project, regardless of where they were declared.

102 

LogicLab user manual 9.1.2.1 ADDING A VARIABLE FROM A TEXTUAL SOURCE CODE EDITOR 

Follow this procedure to add a variable to the *Watch* window from a textual (that is, IL 

or ST) source code editor: select a variable, by double-clicking on it, and then drag it into 

the watch window.

The same procedure applies to all the variables you wish to inspect.

##### 9.1.2.2 ADDING A VARIABLE FROM A GRAPHICAL SOURCE CODE EDITOR 

Follow this procedure to add a variable to the *Watch* window from a graphical (that is, LD, 

FBD, or SFC) source code editor:

1) Click *Edit>Watch mode* .

2) Click on the block representing the variable you wish to be shown in the *Watch* win

dow.

A dialog box appears listing all the currently existing instances of debug windows, and 

asking you which one is to receive the object you have just clicked on.

In order to display the variable in the *Watch* window, select *Watch*, then press *OK*.

The variable name, value, and location are now displayed in a new row of the  Watch  win

LogicLab user manual 

103dow.

The same procedure applies to all the variables you wish to inspect.

Once you have added to the *Watch* window all the variables you want to observe, you 

should click *Edit>Insert/Move mode* : the mouse cursor turns to its original shape.

##### 9.1.2.3 ADDING A VARIABLE FROM A VARIABLES EDITOR 

In order to add a variable to the *Watch* window, you can select the corresponding record 

in the variables editor and then either drag-and-drop it in the *Watch* window

or press the  F8  key.

##### 9.1.2.4 ADDING A VARIABLE FROM THE PROJECT TREE 

In order to add a variable to the *Watch* window, you can select it in the project tree and 

then either drag-and-drop it in the *Watch* window

or press the  F8  key.

104 

LogicLab user manual 9.1.2.5 ADDING A VARIABLE FROM THE WATCH WINDOW TOOLBAR 

You can also click on the appropriate item of the Watch window inner toolbar, in order to 

add a variable to it.

You shall type (or select by browsing the project symbols) the name of the variable and 

its location (where it has been declared).

#### 9.1.3 REMOVING A VARIABLE 

If you want a variable not to be displayed any more in the *Watch* window, select it by 

clicking on its name once, then press the *Del* key.

If you want to remove all item from the *Watch* window, select the following icon:

#### 9.1.4 REFRESHMENT OF VALUES 

##### 9.1.4.1 NORMAL OPERATION 

The watch window manager reads periodically from memory the value of the variables.

However, this action is carried out asynchronously, so it may happen that a higher-priority 

task modifies the value of some of the variables while they are being read. Thus, at the

end of a refreshment process, the values displayed in the window may refer to different

execution states of the PLC code.

##### 9.1.4.2 TARGET DISCONNECTED 

If the target device is disconnected, the *Value* column contains three dots.

LogicLab user manual 

105
##### 9.1.4.3 OBJECT NOT FOUND 

If the PLC code changes and LogicLab cannot retrieve the memory location of an object in 

the *Watch* window, then the *Value* column contains three dots.

LogicLab does not allow you to add to the *Watch* window a symbol which has not been 

allocated, any attempt will be ignored.

#### 9.1.5 CHANGING THE FORMAT OF DATA 

When you add a variable to the *Watch* window, LogicLab automatically recognizes its type 

(unsigned integer, signed integer, floating point, hexadecimal...), and displays its value

consistently. Also, if the variable is floating point, LogicLab assigns it a default number of 

decimal figures.

However, you may need the variable to be printed in a different format.

To impose another format than the one assigned by LogicLab, press the *Format value*

button in the toolbar.

Choose the format and confirm your choice.

106 

LogicLab user manual
#### 9.1.6 WORKING WITH WATCH LISTS 

You can store to file the set of all the items in the *Watch* window, in order to easily restore 

the status of this debugging tools in a successive working session.

Follow this procedure to save a watch list:

1) Click on the corresponding item in the *Watch window* toolbar.

2) Enter the file name and choose its destination in the file system.

When loading a watch list from file, you have two options: you can load the items from

file and append them to the items currently shown in the watch window; or you can auto

matically clear the watch window and display only the items loaded from file. Either way,

follow this procedure and choose the desired option:

1) Click on the corresponding icon in the *Watch* window toolbar. The one labeled *Load* 

*(no appends) watch list* will remove all currently displayed elements and show only 

the ones loaded from file; the icon labeled *Load watch list* will append them instead.

2) Browse the file system and select the watch list file.

LogicLab user manual 

107The set of symbols in the watch list is added to the *Watch* window.

#### 9.1.7 AUTOSAVE WATCH LIST 

By selecting the associated option in the project options dialog (see Paragraph 4.6.5 for 

more info) the watch list will be automatically saved on the project closing.

The saved watch list will be automatically loaded (with no append option) on the first con

nection to target when the project will be re-opened.

### 9.2 OSCILLOSCOPE 

The Oscilloscope allows you to plot the evolution of the values of a set of variables. Be

ing an asynchronous tool, the Oscilloscope cannot guarantee synchronization of samples.

Opening the Oscilloscope causes a new window to appear next to the right-hand border 

of the LogicLab frame. This is the interface for accessing the debugging functions that the 

Oscilloscope makes available. The Oscilloscope consists of three elements, as shown in 

the following picture.

The toolbar allows you to better control the Oscilloscope. A detailed description of the 

108 

LogicLab user manualfunction of each control is given later in this chapter.

The Chart area includes several items:

\- Plot: area containing the curve of the variables.

\- Vertical cursors: cursors identifying two distinct vertical lines. The values of each vari

able at the intersection with these lines are reported in the corresponding columns.

\- Scroll bar: if the scale of the x-axis is too large to display all the samples in the Plot 

area, the scroll bar allows you to slide back and forth along the horizontal axis.

The lower section of the Oscilloscope is a table consisting of a row for each variable.

#### 9.2.1 OPENING AND CLOSING THE OSCILLOSCOPE 

To open, close the Oscilloscope, click *View>Tool windows>Oscilloscope* .

Closing the Oscilloscope means simply hiding it, not resetting it. As a matter of fact, if you 

open again the Oscilloscope after closing it, you will see that plotting of the curve of all 

the variables you added to it starts again.

#### 9.2.2 ADDING ITEMS TO THE OSCILLOSCOPE 

In order to plot the evolution of the value of a variable, you need to add it to the Oscil

loscope.

Note that unlike trigger windows and the *Graphic trigger* window, you can add to the Os

cilloscope all the variables of the project, regardless of where they were declared.

##### 9.2.2.1 ADDING A VARIABLE FROM A TEXTUAL SOURCE CODE EDITOR 

Follow this procedure to add a variable to the Oscilloscope from a textual (that is, IL or 

ST) source code editor: select a variable by double-clicking on it, and then drag it into the 

*Oscilloscope* window.

The same procedure applies to all the variables you wish to inspect.

##### 9.2.2.2 ADDING A VARIABLE FROM A GRAPHICAL SOURCE CODE EDITOR 

Follow this procedure to add a variable to the Oscilloscope from a graphical (that is, LD, 

FBD, or SFC) source code editor:

1) Click *Edit>Watch mode* .

2) Click on the block representing the variable you wish to be shown in the Oscilloscope.

LogicLab user manual 

1093) A dialog box appears listing all the currently existing instances of debug windows, and 

asking you which one is to receive the object you have just clicked on.

Select *Oscilloscope*, the press *OK*. The name of the variable is now displayed in the 

*Track* column.

The same procedure applies to all the variables you wish to inspect.

Once you have added to the Oscilloscope all the variables you want to observe, you should 

click *Edit>Insert/Move mode* : the mouse cursor turns to its original shape.

##### 9.2.2.3 ADDING A VARIABLE FROM A VARIABLES EDITOR 

In order to add a variable to the Oscilloscope, you can select the corresponding record in 

the variables editor and then either drag-and-drop it in the Oscilloscope

or press the *F10* key and choose *Oscilloscope* from the list of debug windows which pops 

up.

##### 9.2.2.4 ADDING A VARIABLE FROM THE PROJECT TREE 

In order to add a variable to the Oscilloscope, you can select it in the project tree and then 

either drag-and-drop it in the Oscilloscope

110 

LogicLab user manualor press the *F10* key and choose *Oscilloscope* from the list of debug windows which pops 

up.

#### 9.2.3 REMOVING A VARIABLE 

If you want to remove a variable from the Oscilloscope, select it by clicking on its name 

once, then press the  Del  key.

#### 9.2.4 VARIABLES SAMPLING 

##### 9.2.4.1 NORMAL OPERATION 

The Oscilloscope manager periodically reads from memory the value of the variables.

However, this action is carried out asynchronously, that is it may happen that a higher

priority task modifies the value of some of the variables while they are being read. Thus,

at the end of a sampling process, data associated with the same value of the x-axis may 

actually refer to different execution states of the PLC code.

##### 9.2.4.2 TARGET DISCONNECTED 

If the target device is disconnected, the curves of the dragged-in variables get frozen, 

until communication is restored.

#### 9.2.5 CONTROLLING DATA ACQUISITION AND DISPLAY 

The Oscilloscope includes a toolbar with several commands, which can be used to control 

the acquisition process and the way data are displayed. This paragraph focuses on these 

commands.

Note that all the commands in the toolbar are disabled if no variable has been added to 

the Oscilloscope.

LogicLab user manual 

111
##### 9.2.5.1 STARTING AND STOPPING DATA ACQUISITION 

When you add a variable to the Oscilloscope, data acquisition begins immediately.

However, you can suspend the acquisition by clicking on *Pause acquisition.*

The curve freezes (while the process of data acquisition is still running in background), 

until you click on *Restart acquisition*.

In order to stop the acquisition you may click on *Stop acquisition*.

In this case, when you click on *Restart acquisition*, the evolution of the value of the vari

able is plotted from scratch.

#### 9.2.5.2 SETTING THE SCALE OF THE AXES 

When you open the Oscilloscope, LogicLab applies a default scale to the axes. However, if 

you want to set a different scale, you can do that by opening the graph properties clicking

on the corresponding icon in the toolbar:

The graph settings window will open, allowing you to change both the vertical and the 

horizontal axis.

The horizontal scale is the same for every track.

The vertical scale can be different for every variable, you can specify the desired scale in

the edit box labeled *Value/div.*

112 

LogicLab user manual
##### 9.2.5.3 CHANGE THE ZOOM 

In the Oscilloscope toolbar you can also find icons for zoom in and out, and also to force

the Oscilloscope to display all the sample.

These options are axis-related, so you can zoom in, zoom out and show all samples for 

the horizontal axis alone:

as well as you can zoom in, zoom out and show all samples for the vertical axis alone:

You can also quickly force the oscilloscope to display all samples for both horizontal and 

vertical axis (which means show all values) with a specific icon:

##### 9.2.5.4 VERTICAL SPLIT 

When you are watching the evolution of two or more variables, you may want to split 

the respective tracks. For this purpose, click on the *Vertical split* item in the Oscilloscope 

toolbar.

To separate traces you can also manually move them; to do so grab the corresponding 

coloured flag on the left of the chart and drag it to the desired location.

LogicLab user manual 

113
##### 9.2.5.5 VIEWING SAMPLES 

If you click on the *Show samples* item in the *Oscilloscope* toolbar, the tool highlights the 

single values detected during data acquisition.

You can click on the same item again, in order to go back to the default view mode.

##### 9.2.5.6 TAKING MEASURES 

The Oscilloscope includes two measure bars, which can be exploited to take some meas

ures on the chart; in order to show and hide them, click on the *Show measure bars* item 

in the Oscilloscope toolbar.

If you want to measure a time interval between two events, you just have to move one 

bar to the point in the graph that corresponds to the first event and the other to the point

that corresponds to the second one.

The time interval between the two bars is shown in the top left corner of the chart.

You can use a measure bar also to read the value of all the variables in the Oscilloscope 

at a particular moment: move the bar to the point in the graph which corresponds to the 

instant you want to observe.

In the table below the chart, you can now read the values of all the variables at that par

ticular moment.

114 

LogicLab user manualIn addition to the vertical bar, by enabling the measure bars, you will also find two hori

zontal bars on the right of the grid. They work the same way of the vertical bars, but they 

take values on the vertical axis.

Like the vertical bars, also the horizontal bars have their values displayed for every vari

able in the table below the chart.

##### 9.2.5.7 OSCILLOSCOPE SETTINGS 

You can further customize the appearance of the Oscilloscope by clicking on the *Graph* 

*properties* item in the toolbar.

In the window that pops up you can choose whether to display or not the *Background* 

*grid*, the *Time slide bar*, and the *Track list*.

##### 9.2.5.8 CHANGING THE POLLING RATE 

LogicLab periodically sends queries to the target device, in order to read the data to be 

plotted in the Oscilloscope.

The polling rate can be configured by modifying the *Sample polling rate* voice in the Oscil

loscope settings window.

Note that the actual rate depends on the performance of the target device, in particular 

on the performance of its communication task. 

LogicLab user manual 

115
#### 9.2.6 SAVING, RESTORING AND PRINTING THE GRAPH 

LogicLab allows you to persist the acquisition either by saving the data to a file or by print

ing a view of the data plotted in the Oscilloscope.

##### 9.2.6.1 SAVING DATA TO A FILE 

You can save the samples acquired by the Oscilloscope to a file, in order to further analyze

the data with other tools.

1) You may want to stop acquisition before saving data to a file.

2) Click on the *Save tracks data into file* in the Oscilloscope toolbar.

3) Choose between the available output file format: OSC is a simple plain-text file, con

taining time and value of each sample; OSCX is an XML file, that includes more

complete information, which can be further analyzed with another tool, provided 

separately from LogicLab.

4) Choose a file name and a destination directory, then confirm the operation.

##### 9.2.6.2 RESTORING DATA INTO THE GRAPH (CURRENTLY NOT IMPLEMENTED) 

The oscilloscope allows you to restore data previously saved on file; you have two option

to do so: *Load and append graph data* or *Load (no append) graph data*.

In both cases youâ€™ll have to select the OSC (or OSCX) file to load; then if youâ€™ve choose

to load and append, the data taken from the file will be added to the list of those al

ready inside the oscilloscope; if youâ€™ve choose to load without append, the variables list 

of the oscilloscope will be cleared before adding the data taken from the file.

##### 9.2.6.3 PRINTING THE GRAPH 

Follow this procedure to print a view of the data plotted in the Oscilloscope:

1) Either suspend or stop the acquisition.

2) Only the elements included in the view will be printed, so move the time slide bar 

and adjust the zoom, in order to include in the view the elements you want to print. 

3) Click on the *Print graph* item.

116 

LogicLab user manual
### 9.3 EDIT AND DEBUG MODE 

While both the *Watch* window and the Oscilloscope do not make use of the source code, 

all the other debuggers do: when debug mode is on, changes to the source code are in

hibited and debug tools become active.

LogicLab automatically enables debug mode when at least one of the following conditions 

are met:

\- at least one breakpoint is correctly set.

\- At least one trigger (graphic or textual) is correctly set.

\- Live debug mode is on.

When all the conditions above are not met, the debug mode automatically switches off

and LogicLab enters in edit mode.

The status bar shows whether the debug mode is active or not.

Note that you cannot enter the debug mode if the connection status differs from *Con*

*nected*.

### 9.4 LIVE DEBUG 

LogicLab can display meaningful animation of the current and changing state of execution 

over time of a Program Organization Unit (POU) coded in any IEC 61131-3 programming 

language.

To switch on and off the live debug mode, you may click *Debug>Live debug mode* .

#### 9.4.1 SFC ANIMATION 

As explained in the relevant section of the language reference, an SFC POU is structured 

in a set of steps, each of which is either active or inactive at any given moment. Once 

started up, this SFC-specific debugging tool animates the SFC documents by highlighting

the active steps.

 Animation OFF  

 Animation ON  

 Animation ON in hold  

 status 

In the left column, a portion of an SFC network is shown, diagram animation being off.

In the middle column the same portion of network is displayed when the live debug mode 

is active. The picture in the middle column shows that steps S1 and S3 are currently ac

tive, whereas Init, S2, and S4 are inactive.

In the right column the same portion of network is displayed with steps S1 and S3 that are 

currently active but in hold status.

LogicLab user manual 

117This may occur in SFC blocks when they are children of a parent in inactive status.

Note that the SFC animation manager tests periodically the state of all steps, the user not 

being allowed to edit the sampling period. Therefore, it may happen that a step remains 

active for a slot of time too short to be displayed.

The fact that a step is never highlighted does not imply that its action is not executed, it 

may simply mean that the sampling rate is too slow to detect the execution.

##### 9.4.1.1 DEBUGGING ACTIONS AND CONDITIONS 

As explained in the SFC language reference, an action can be assigned to a step, and 

a transition can be associated with a transition code (condition). Actions and transition 

codes can be coded in any of the IEC 61131-3 languages (except SFC for transition code). 

General-purpose debugging tools can be used within each action/condition, as if it was a 

stand-alone POU.

#### 9.4.2 LD ANIMATION 

In live debug mode, LogicLab displays the values of all the visible variables directly in the 

graphical source code editor.

Note that the LD animation manager tests periodically the state of all the elements. It 

may happen that an element remains true for a slot of time too short to be displayed 

on the video. The fact that an element is never highlighted does not imply that its value 

never becomes true (the sampling rate may be too slow).

#### 9.4.3 FBD ANIMATION 

In live debug mode, LogicLab displays the values of all the visible variables directly in the 

graphical source code editor.

Note that the LD animation manager tests periodically the state of all the elements. It 

may happen that an element remains true for a slot of time too short to be displayed 

on the video. The fact that an element is never highlighted does not imply that its value 

never becomes true (the sampling rate may be too slow).

118 

LogicLab user manual
#### 9.4.4 IL AND ST ANIMATION 

The live debug mode also applies to textual source code editors (the ones for IL and ST). 

The values of a variable is directly displayed in a green box just at the right of the vari

able.

### 9.5 TRIGGERS 

#### 9.5.1 TRIGGER WINDOW 

The *Trigger window* tool allows you to watch the value of a set of variables and to have 

them updated synchronously in a special pop-up window.

##### 9.5.1.1 PRE-CONDITIONS TO OPEN A TRIGGER WINDOW 

 No need for special compilation 

LogicLab debugging tools operate at run-time. Thus, unlike other programming languages 

such as C++, the compiler does not need to be told whether or not to support trigger 

windows: given a PLC code, the compilerâ€™s output is unique, and there is no distinction 

between debug and release version.

 Memory availability 

A trigger window takes a segment in the application code sector, having a well-defined

length. Obviously, in order to start up a trigger window, it is necessary that a sufficient

amount of memory is available, otherwise an error message appears.

 Incompatibility with graphic trigger windows 

A graphic trigger window takes the whole free space of the application code sector. There

fore, once such a debugging tool has been started, it is not possible to add any trigger 

window, and an error message appears if you attempt to start a new window. Once the 

graphic trigger window is eventually closed, trigger windows are enabled again.

Note that all the trigger windows existing before the starting of a graphic trigger window 

keep working normally. You are simply not allowed to add new ones.

##### 9.5.1.2 SET AND REMOVE TRIGGERS 

From the *Debug* menu you can select the appropriate voice for work with triggers.

Triggers can be palced only if a valid connection is established and the PLC is currently 

executing.

From the *Debug* menu you can choose the following voices: 

LogicLab user manual 

119 Command 

 Icon in  

 debug  

 toolbar 

 Description 

*Add/Remove text* 

*trigger*

In order to actually start a trigger window, select 

the point of the PLC code where to insert the 

relative trigger and then press this button or use 

the shortcut pressing *F9.*

Do the same to remove the trigger.

*Add/Remove* 

*graphic trigger*

This button operates exactly as the above *Set/*

*Remove trigger*, except for that it opens a graphic 

trigger window. It can be used likewise also to 

remove a graphic trigger window. Shortcut key: 

pressing  Shift + F9 .

*Remove all triggers*

Pressing this key causes all the existing trigger 

windows and the graphic trigger window to be 

removed simultaneously. Shortcut key: pressing 

*Ctrl+Shift+F9* is equivalent to clicking on this 

button.

*Trigger list*

This key opens a dialog listing all the existing 

trigger windows. Shortcut key: pressing *Ctrl+I* is 

equivalent to clicking on this button.

Each record refers to a trigger window, either graphic or textual. The following table ex

plains the meaning of each field.

 Field  

 Description 

*Type*

 T : trigger window.

 G : graphic trigger window.

*Module*

Name of the program, function, or function block where 

the trigger is placed. If the module is a function block, this 

field contains its name, not the name of its instance where

you actually put the trigger.

 Line 

For the textual languages (IL, ST) indicates the line in 

which the trigger is placed. For the other languages the 

value is always  -1 .

120 

LogicLab user manual 9.5.1.3 TRIGGER WINDOW INTERFACE 

Setting a trigger causes a pop-up window to appear, which is called *Interface* window: 

this is the interface to access the debugging functions that the trigger window makes 

available. It consists of three elements, as shown below.

 Caption bar 

The *Caption* bar of the pop-up window shows information on the location of the trigger 

which causes the refresh of the *Variables* window, when reached by the processor.

The text in the *Caption* bar has the following format:

Trigger nÂ° X at ModuleName#Location

where

 X  

Trigger identifier.

 ModuleName  

Name of the program, function, or function block where 

the trigger was placed.

 Location 

Exact location of the trigger, within module *ModuleName*.

If *ModuleName* is in IL, *Location* has the following format:

N1

Otherwise, if *ModuleName* is in FBD, it becomes:

N2$BT:BID

where:

N1 = instruction line number

N2 = network number

BT = block type (operand, function, function block, etc.)

BID = block identifier

 Controls section 

This dialog box allows the user to better control the refresh of the trigger window to get 

more information on the code under scope. A detailed description of the function of each 

control is given in the *Trigger window* controls section (see Paragraph 9.5.2.11).

All controls are not accessible until at least one variable is dragged into the debug window. 

LogicLab user manual 

121 The Variables section 

This lower section of the *Debug* window is a table consisting of a row for each variable 

that you dragged in. Each row has four fields: the name of the variable, its value, its type,

and its location (@task:ModuleName) read from memory during the last refresh.

 9.5.1.4 TRIGGER WINDOW: DRAG AND DROP INFORMATION 

To watch a variable, you need to copy it to the lower section of the  Debug  window.

This section is a table consisting of a row for each variable you dragged in. You can drag 

into the trigger window only variables local to the module where you placed the relative 

trigger, or global variables, or parameters. You cannot drag variables declared in another 

program, or function, or function block.

##### 9.5.1.5 REFRESH OF THE VALUES 

Let us consider the following example.

122 

LogicLab user manualThe value of variables is refreshed every time the window manager is triggered, that is 

every time the processor executes the instruction marked by the green arrowhead. How

ever, you can set controls in order to have variables refreshed only when triggers satisfy 

the more limiting conditions you define.

Note that the value of the variables in column *Symbol* is read from memory just before 

the marked instruction (in this case: the instruction at line 5) and immediately after the 

previous instruction (the one at line 4) has been performed.

Thus, in the above example the second ST statement has not been executed yet when the 

new value of  a  is read from memory and displayed in the trigger window. Thus the result 

of the second ST  a  is 1.

 9.5.1.6 TRIGGER WINDOW CONTROLS 

This paragraph deals with the trigger window controls, which allows you to better super

vise the working of this debugging tool, to get more information on the code under scope.

Trigger window controls act in a well-defined way on the behaviour of the window, re

gardless for the type of the module (either IL or FBD) where the related trigger has been 

inserted. 

All controls are not accessible until at least one variable is dragged into the *Variables*

window. 

Window controls are made accessible to users through the grey top half of the debug 

window.

 Button  

 Command  

 Description 

 Start/Stop 

This control is used to start a triggering session. 

If system is triggering you can click this button to 

force stop. Otherwise session automatically stops 

when conditions are reached. At this point you 

can press this button to start another triggering 

session.

 Single step  

 execution 

This control is used to execute a single step 

trigger. It is enabled only when there is no active 

triggering session and *None* is selected. Specified

condition is considered. After the single step 

trigger is done, triggering session automatically 

stops.

 Trigger counter 

This read-only control counts how many times the debug window manager has been trig

gered, since the window was installed. 

The window manager automatically resets this counter every time a new triggering ses

sion is started.

 Trigger state 

This read-only control shows the user the state of the  Debug  window. It can assume the 

following values.

The trigger has not occurred during the current task execution.

LogicLab user manual 

123The trigger has occurred during the current task execution.

System is not triggering. Triggering has not been started yet 

or it has been stopped by user or an halt condition has been 

reached.

Communication with target interrupted, the state of the trigger 

window cannot be determined.

 User-defined condition 

If you define a condition by using this control, the values in the  Debug  window are re

freshed every time the window manager is triggered and the user-defined condition is

true. 

After you have entered a condition, the control displays its simplified expression.

 Counters 

These controls allow the user to define conditions on the trigger counter.

The trigger window can be in one of the following three states.

\- *None*: no counter has been started up, thus no condition has been specified upon the

trigger.

\- *For*: assuming that you gave the counter limit the value N, the window manager adds 

 1  to the current value of the counter and refreshes the value of its variables, each time 

the debug window is triggered. However, when the counter equals N, the window stops 

refreshing the values, and it changes to the  Stop  state. 

\- *After*: assuming that you gave the counter limit the value N, the window manager re

sets the counter and adds  1  to its current value each time it is triggered. The window 

remains in the  Ready  state and does not update the value of its variables until the 

counter reaches N.

#### 9.5.2 DEBUGGING WITH TRIGGER WINDOWS 

##### 9.5.2.1 INTRODUCTION 

The trigger window tool allows the user to select a set of variables and to have their val

ues displayed and updated synchronously in a pop-up window. Unlike the  Watch  window, 

trigger windows refresh simultaneously all the variables they contain, every time they are 

triggered.

##### 9.5.2.2 OPENING A TRIGGER WINDOW FROM AN IL MODULE 

Let us assume that you have an IL module, also containing the following instructions.

124 

LogicLab user manualLet us also assume that you want to know the value of b, d, and k, just before 

the  ST k  instruction is executed. To do so, move the cursor to line 12, then click 

 *Debug>Add/Remove text trigger* .

A green arrowhead appears next to the line number, and the related trigger window pops 

up.

Not all the IL instructions support triggers. For example, it is not possible to place a trig

ger at the beginning of a line containing a JMP statement.

##### 9.5.2.3 ADDING A VARIABLE TO A TRIGGER WINDOW FROM AN IL MODULE 

In order to watch the value of a variable, you need to add it to the trigger window. To this 

purpose, select a variable by double-clicking it, and then drag it into the *Variables* win

dow, that is the lower white box in the pop-up window. The variableâ€™s name now appears 

in the *Symbol* column. 

LogicLab user manual 

125The same procedure applies to all the variables you wish to inspect.

##### 9.5.2.4 OPENING A TRIGGER WINDOW FROM AN FBD MODULE 

Let us assume that you have an FBD module, also containing the following instructions.

Let us also assume that you want to know the values of C, D, and K, just before the last 

instruction is executed.

Provided that you can never place a trigger in a block representing a variable such as

you must select the first available block preceding the selected variable. In the example

of the above figure, you must move the cursor to network 8, and click the ADD block.

126 

LogicLab user manualYou can click *Debug>Add/Remove text trigger* .

Else, you can also insert trigger on the whole line; this means youâ€™ll hit the trigger just 

before the first instruction of that line is executed. To do so, select the row by clicking the

gray button on the left (the one with the row number inside) and add the trigger.

In both cases, the color of the selected block turns to green, a white circle with a number 

inside appears in the middle of the block, and the related trigger window pops up.

When preprocessing FBD source code, the compiler translates it into IL instructions. The 

instruction in the selected network will be expanded to:

LD k 

ADD 1

ST k

When you add a trigger to an FBD block, you actually place the trigger on the first state

ment of its IL equivalent code. 

##### 9.5.2.5 ADDING A VARIABLE TO A TRIGGER WINDOW FROM AN FBD MODULE 

In order to watch the value of a variable, you need to add it to the trigger window. Let 

us assume that you want to inspect the value of variable k of the FBD code in the figure

below.

To this purpose, click *Edit>Watch mode* .

The cursor will become as follows.

Now you can click the block representing the variable you wish to be shown in the trigger 

window.

Now select the element you wish to inspect, in our example letâ€™s suppose the variable *K*.

A dialog box appears listing all the currently existing instances of debug windows, and 

asking you which one is to receive the object you have just clicked.

LogicLab user manual 

127In order to display the variable k in the trigger window, select its reference in the  Debug  

 windows  column, then press  OK . The name of the variable is now printed in the  Symbol 

column.

The same procedure applies to all the variables you wish to inspect.

Once you have added to the  Graphic watch  window all the variables you want to observe, 

you can click *Edit>Insert/Move mode* , so as to let the cursor take back its original shape.

##### 9.5.2.6 OPENING A TRIGGER WINDOW FROM AN LD MODULE 

Let us assume that you have an LD module containing the following instructions:

128 

LogicLab user manualYou can place a trigger directly on a block, a contact, a coil or the entire row.

Let us assume that you want to know the value of some variables every time the pro

cessor reaches network number 1. First select the network number 1 by clicking on 

the grey area on its left, the one containing the network number. Now you can click 

 *Debug>Add/Remove text trigger* .

In both cases, the grey raised button containing the network number turns to green, and 

a white circle with the number of the trigger inside appears in the middle of the button, 

while the related trigger window pops up.

Unlike the other languages supported by LogicLab, LD does not allow you to insert a 

trigger into a single contact or coil, as it lets you select only an entire network. Thus the 

variables in the trigger window will be refreshed every time the processor reaches the 

beginning of the selected network.

##### 9.5.2.7 ADDING A VARIABLE TO A TRIGGER WINDOW FROM AN LD MODULE 

In order to watch the value of a variable, you need to add it to the trigger window. Let 

us assume that you want to inspect the value of variable b in the LD code represented in 

the figure below.

To this purpose, click *Edit>Watch mode* .

The cursor will become as follows.

LogicLab user manual 

129Now you can click the item representing the variable you wish to be shown in the trigger 

window.

A dialog box appears listing all the currently existing instances of debug windows, and 

asking you which one is to receive the object you have just clicked.

In order to display variable *parPulseWidth* in the trigger window, select its reference in the 

 D *ebug window* column, then press *OK*.

The name of the variable is now printed in the *Symbol* column.

The same procedure applies to all the variables you wish to inspect.

Once you have added to the *Graphic watch* window all the variables you want to observe, 

you can click *Edit>Insert/Move mode* , so as to restore the original shape of the cursor.

##### 9.5.2.8 OPENING A TRIGGER WINDOW FROM AN ST MODULE 

Let us assume that you have an ST module containing the following instructions.

130 

LogicLab user manualLet us assume that you want to know the value of *x* and *y*, just before the *for* cycle is 

executed. To do so, move the cursor to line 6 and click *Debug>Add/Remove text trigger* .

A green arrowhead appears next to the line number, and the related trigger window pops 

up.

Not all the ST instructions support triggers. For example, it is not possible to place a trig

ger on a line containing a terminator such as END_IF, END_FOR, END_WHILE, etc..

##### 9.5.2.9 ADDING A VARIABLE TO A TRIGGER WINDOW FROM AN ST MODULE 

In order to watch the value of a variable, you need to add it to the trigger window. To this 

purpose, select a variable, by double clicking it, and then drag it into the *Variables* win

dow, that is the lower white box in the pop-up window. The variable name now appears 

in the *Symbol* column.

The same procedure applies to all the variables you wish to inspect.

##### 9.5.2.10 REMOVING A VARIABLE FROM THE TRIGGER WINDOW 

If you want a variable not to be displayed any more in the trigger window, select it by 

clicking its name once, then press the *Del* key.

##### 9.5.2.11 CLOSING A TRIGGER WINDOW AND REMOVING A TRIGGER 

This page deals with what you can do when you finish a debug session with a trigger win

dow. You can choose between the following options.

\- Closing the trigger window.

\- Removing the trigger.

\- Removing all the triggers.

LogicLab user manual 

131Notice that the actions listed above produce very different results.

 Closing the trigger window 

If you close a trigger window youâ€™re just hiding its interface window, the trigger is still ac

tive. You will still see the green arrowhead (or the network highlighted).

The fact that the trigger is active, means it is still working, if you reopen the interface you 

wonâ€™t find it at the same status it was when you closed it; for example the counter may

have raised.

You can reopen the interface window, to resume working with the same trigger, by open

ing the *Trigger list* window, select the record referred to that trigger, and click the *Open*

button.

The interface window appears with value of variables and trigger counter updated, as if it 

had not been closed.

 Removing a trigger 

If you choose this option, you completely remove the code both of the window manager 

and of its trigger. To this purpose, just open the *Trigger list* window, select the record 

referred to the trigger window you want to eliminate, and click the *Remove* button.

Alternatively, you can move the cursor to the line (if the module is in IL or ST), or 

click the block (if the module is in FBD or LD) where you placed the trigger. Now press 

*Debug>Add/Remove trigger* .

 Removing all the triggers 

If you wish, you can remove all the existing triggers at once, regardless for which records 

are selected, by clicking on the *Remove all* button from the *Trigger list* window.

132 

LogicLab user manualAlternatively you can select *Debug>Remove all triggers* .

### 9.6 GRAPHIC TRIGGERS 

#### 9.6.1 GRAPHIC TRIGGER WINDOW 

The graphic trigger window tool allows you to select a set of variables and to have them 

sampled synchronously and to have their curve displayed in a special pop-up window.

Sampling of the dragged-in variables occurs every time the processor reaches the position 

(i.e. the instruction - if IL, ST - or the block - if FBD, LD) where you placed the trigger.

##### 9.6.1.1 PRE-CONDITIONS TO OPEN A GRAPHIC TRIGGER WINDOW 

 No need for special compilation 

All the LogicLab debugging tools operate at run-time. Thus, unlike other programming 

languages such as C++, the compiler does not need to be told whether or not to support 

trigger windows: given a PLC code, the compilerâ€™s output is unique, and there is no dis

tinction between debug and release version.

 Memory availability 

A graphic trigger window takes all the free memory space in the application code sector. 

Obviously, in order to start up a trigger window, it is necessary that a sufficient amount

of memory is available, otherwise an error message appears.

##### 9.6.1.2 GRAPHIC TRIGGER WINDOW INTERFACE 

Setting a graphic trigger causes a pop-up window to appear, which is called *Interface*

window. This is the main interface for accessing the debugging functions that the graphic 

trigger window makes available. It consists of several elements, as shown below.

 1.  *Caption bar*  2.  *Controls bar*  3.  *Chart area*  4.  *Variables window*

LogicLab user manual 

133 The caption bar 

The *Caption* bar at the top of the pop-up window shows information on the location of the 

trigger which causes the variables listed in the *Variables* window to be sampled.

The text in the caption has the following format:

ModuleName#Location

Where

ModuleName Name of program, function, or function block where the trigger was 

placed.

Location

Exact location of the trigger, within module ModuleName.

If ModuleName is in IL, ST, Location has the format:

N1

Otherwise, if ModuleName is in FBD, LD, it becomes:

N2$BT:BID

N1 = instruction line number

N2 = network number

BT = block type (operand, function, function block, etc.)

BID = block identifier

 The Controls bar 

This dialog box allows you to better control the working of the graphic trigger window. A 

detailed description of the function of each control is given in the *Graphic trigger* window 

controls section (see Paragraph 9.6.1.5).

 The Chart area 

The *Chart* area includes six items:

1) Plot: area containing the actual plot of the curve of the dragged-in variables. 

2) Samples to acquire: number of samples to be collected by the graphic trigger window 

manager. 

3) Horizontal cursor: cursor identifying a horizontal line. The value of each variable at 

the intersection with this line is reported in the column *horz cursor*. 

4) Blue cursor: cursor identifying a vertical line. The value of each variable at the inter

section with this line is reported in the column *left cursor*. 

5) Red cursor: same as blue cursor. 

6) Scroll bar: if the scale of the x-axis is too large to display all the samples in the *Plot*

area, the scroll bar allows you to slide back and forth along the horizontal axis. 

 The Variables window 

This lower section of the  Debug  window is a table consisting of a row for each variable 

that you have dragged in. Every row has several fields, which are described in detail in

the Drag and drop information section.

##### 9.6.1.3 GRAPHIC TRIGGER WINDOW: DRAG AND DROP INFORMATION 

To watch a variable, you need to copy it to the lower section of the *Debug* window.

This lower section of the *Debug* window is a table consisting of a row for each variable 

that you dragged in. Each row has several fields, as shown in the picture below.

134 

LogicLab user manual Field  

 Description 

*Track* 

Name of the variable.

*Um* 

Unit of measurement.

*Min value* 

Minimum value in the record set.

*Max value* 

Maximum value in the record set.

*Cur value* 

Current value of the variable.

*v/div*

How many engineering units are represented by a unit 

of the y-axis (i.e. the space between two ticks on the 

vertical axis).

*V Blue cursor* Value of the variable at the intersection with the line 

identified by the vertical blue cursor.

*V Red cursor* Value of the variable at the intersection with the line 

identified by the vertical red cursor.

*H Red cursor* Value of the variable at the intersection with the line 

identified by the horizontal red cursor.

*H Blue cursor* Value of the variable at the intersection with the line 

identified by the horizontal red cursor.

*Description* 

Information about the variable in watch, like its parent 

POU and the execution task

Note that you can drag into the graphic trigger window only variables local to the module 

where you placed the relative trigger, or global variables, or parameters. You cannot drag 

variables declared in another program, or function, or function block.

##### 9.6.1.4 SAMPLING OF VARIABLES 

Let us consider the following example.

The value of the variables is sampled every time the window manager is triggered, that is 

every time the processor executes the instruction marked by the green arrowhead. How

ever, you can set controls in order to have variables sampled when triggers also satisfy 

further limiting conditions that you define.

The value of the variables in the column *Track* is read from memory just before the 

marked instruction and immediately after the previous instruction.

LogicLab user manual 

135
##### 9.6.1.5 GRAPHIC TRIGGER WINDOW CONTROLS 

This paragraph deals with controls of the *Graphic trigger* window. Controls allow you to 

specify in detail when LogicLab is supposed to sample the variables added to the  V *ariables*

window.

Graphic trigger window controls act in a well-defined way on the behaviour of the window,

regardless for the type of the module (IL, ST, FBD or LD) where the related trigger has 

been inserted. 

Window controls are made accessible to users through the *Controls* bar of the debug 

window.

 Button  

 Command  

 Description 

*Start graphic trace*

When you push this button down, you let 

acquisition start. Now, if acquisition is running 

and you release this button, you stop the sample 

collection process, and you reset all the data you 

have acquired so far.

*Enable/Disable* 

*cursors*

The two cursors (red cursor, blue cursor) may be 

seen and moved along their axis as long as this 

button is pressed. Release this button if you want 

to hide simultaneously all the cursors.

*Show samples*

This control is used to put in evidence the exact 

point in which the variables are triggered at each 

sample.

*Split tracks*

When pressed, this control splits the y-axis into 

as many segments as the dragged-in variables, 

so that the diagram of each variable is drawn in a 

separate band.

*Show all values*

It is used to fill in the graph window all the values

sampled for the selected variables in the current 

record set.

*Horizontal Zoom In* 

*and Zoom Out*

Zooming in is an operation that makes the curves 

in the *Chart* area appear larger on the screen, 

so that greater detail may be viewed. Zooming 

out is an operation that makes the curves appear 

smaller on the screen, so that it may be viewed 

in its entirety. Horizontal zoom acts only on the 

horizontal axis.

*Horizontal show all*

This control is used to horizontally center record 

set samples. So first sample will be placed on the

left margin, and last will be placed on the right 

margin of the graphic window.

*Vertical Zoom In and* 

*Zoom Out* 

*Vertical Zoom* acts only on the vertical axis.

*Vertical show all*

This control is used to vertically center record set 

samples. So max value sample will be placed near 

top margin and low value sample will be placed on 

the bottom margin of the graphic window.

136 

LogicLab user manual Button  

 Command  

 Description 

*Stop acquisition* 

Not implemented.

*Pause acquisition* 

Not implemented.

*Restart acquisition* 

Not implemented.

*Graphic trigger* 

*window properties*

Pushing this button causes a tabs dialog box 

to appear, which allows you to set general user 

options affecting the action of the graphic trigger

window. Since the options you can set are quite 

numerous, they are dealt with in a section apart. 

Click here to access this section.

*Save chart* 

Press this button to save the chart.

*Load data (no* 

*append)* 

Not implemented.

*Load data and* 

*append* 

Not implemented.

*Print chart* 

Push this button to print both the *Chart area* and 

the *Variables* window.

 Trigger counter 

This read-only control displays two numbers with the following format: X/Y.

X indicates how many times the debug window manager has been triggered, since the 

graphic trigger was installed. 

Y represents the number of samples the graphic window has to collect before stopping 

data acquisition and drawing the curves. 

 Trigger state 

This read-only control shows you the state of the  Debug  window. It can assume the fol

lowing values.

No sample(s) taken, as the trigger has not occurred during the 

current task execution.

Sample(s) collected, as the trigger has occurred during the 

current task execution.

The trigger counter indicates that a number of samples 

has been collected satisfying the user request or memory 

constraints, thus the acquisition process is stopped. 

Communication with target interrupted, the state of the trigger 

window cannot be determined.

LogicLab user manual 

137
##### 9.6.1.6 GRAPHIC TRIGGER WINDOW OPTIONS 

In order to open the options tab, you must click the *Properties* button in the *Controls* bar. 

When you do this, the following dialog box appears.

 Control 

 Control  

 Description 

*Show grid* 

Tick this control to display a grid in the *Chart area*

background.

*Show time bar* The scroll bar at the bottom of the  available as long as this box is checked. *Chart area* is 

*Show tracks* 

*list*

The 

*Variables* window is shown as long as this box 

is checked, otherwise the 

*Chart area* extends to the 

bottom of the graphic trigger window.

 Values 

 Control  

 Description 

*Horizontal*

*scale* 

Number of samples per unit of the x-axis. By unit of the 

x-axis the space is meant between two vertical lines of 

the background grid.

*Buffer size*

Number of samples to acquire. When you open the 

option tab, after having dragged-in all the variables you 

want to watch, you can read a default number in this 

field, representing the maximum number of samples you

can collect for each variable. You can therefore type a 

number which is less or equal to the default one.

 Tracks 

This tab allows you to define some graphic properties of the plot of each variable. To select

a variable, click its name in the *Track list* column.

138 

LogicLab user manual Control  

 Description 

*Unit* 

Unit of measurement, printed in the table of the 

*Variables* window.

*Value/div*

Î” value per unit of the y-axis. By unit of the y-axis is

meant the space between two horizontal lines of the 

background grid.

*Hide* 

Check this flag to hide selected track on the graph.

Push *Apply* to make your changes effective, or push *OK* to apply your changes and to 

close the options tab.

 User-defined condition 

If you define a condition by using this control, the sampling process does not start until

that condition is satisfied. Note that, unlike trigger windows, once data acquisition begins,

samples are taken every time the window manager is triggered, regardless of the user 

condition being still true or not. 

After you enter a condition, the control displays its simplified expression.

#### 9.6.2 DEBUGGING WITH THE GRAPHIC TRIGGER WINDOW 

The graphic trigger window tool allows you to select a set of variables and to have them 

sampled synchronously and their curve displayed in a special pop-up window.

##### 9.6.2.1 OPENING THE GRAPHIC TRIGGER WINDOW FROM AN IL MODULE 

Let us assume that you have an IL module, also containing the following instructions.

Let us also assume that you want to know the value of a, c, and k, just be

fore the  ST k  instruction is executed. To do so, move the cursor to line 12 and click 

 *Debug>Add/Remove graphic trigger* .

A green arrowhead appears next to the line number, and the graphic trigger window pops 

up.

LogicLab user manual 

139Not all the IL instructions support triggers. For example, it is not possible to place a trig

ger at the beginning of a line containing a JMP statement.

##### 9.6.2.2 ADDING A VARIABLE TO THE GRAPHIC TRIGGER WINDOW FROM AN IL  

 MODULE 

In order to get the diagram of a variable plotted, you need to add it to the graphic trigger 

window. To this purpose, select a variable, by double clicking it, and then drag it into the 

*Variables* window. The variable now appears in the *Track* column.

The same procedure applies to all the variables you wish to inspect.

Once the first variable is dropped into a graphic trace, the *Graphic properties* window is 

automatically shown and allows the user to setup sampling and visualization properties.

##### 9.6.2.3 OPENING THE GRAPHIC TRIGGER WINDOW FORM AN FBD MODULE 

Let us assume that you have an FBD module, also containing the following instructions.

140 

LogicLab user manualLet us also assume that you want to know the values of a, c, and k, just before the last 

instruction is executed.

Provided that you can never place a trigger in a block representing a variable such as

you must select the first available block preceding the selected variable. In the example

of the above figure, you must move the cursor to network 8, and click the ADD block.

Now click *Debug>Add/Remove graphic trigger* .

Else, you can also insert trigger on the whole line; this means youâ€™ll hit the trigger just 

before the first instruction of that line is executed. To do so, select the row by clicking the

gray button on the left (the one with the row number inside) and add the trigger.

In both cases the colour of the selected block will turn to green, a white circle with the 

trigger ID number inside will appear in the middle of the block, and the related trigger 

interface window will pop up.

When preprocessing the FBD source code, compiler translates it into IL instructions. The 

 ADD  instruction in network 8 is expanded to:

LD k 

LogicLab user manual 

141ADD 1

ST k

When you add a trigger to an FBD block, you actually place the trigger before the first

statement of its IL equivalent code. 

##### 9.6.2.4 ADDING A VARIABLE TO THE GRAPHIC TRIGGER WINDOW FROM AN FBD  

 MODULE 

In order to watch the diagram of a variable, you need to add it to the trigger window. Let 

us assume that you want to see the plot of the variable  k  of the FBD code in the figure

below.

To this purpose, click *Edit>Watch mode* .

The cursor will become as follows. 

Now you can click the block representing the variable you wish to be shown in the graphic 

trigger window.

In the example we are considering, click the button block.

A dialog box appears listing all the currently existing instances of debug windows, and 

asking you which one is to receive the object you have just clicked.

In order to plot the curve of variable  k , select *Graphic Trace* in the *Debug windows* col

umn, then press *OK*. The name of the variable is now printed in the *Track* column.

142 

LogicLab user manualThe same procedure applies to all the variables you wish to inspect.

Once you have added to the *Graphic watch* window all the variables you want to observe, 

you can click *Edit>Insert/Move mode* , in order to restore the original cursor.

Once the first variable is dropped into a graphic trace, the *Graphic properties* window is 

automatically shown and allows the user to setup sampling and visualization properties.

##### 9.6.2.5 OPENING THE GRAPHIC TRIGGER WINDOW FROM AN LD MODULE 

Let us assume that you have an LD module, also containing the following instructions.

You can place a graphic trigger directly on a block, a contact, a coil or the entire row.

Let us assume that you want to know the value of some variables every time the pro

cessor reaches network number 1. First select the network number 1 by clicking on 

the grey area on its left, the one containing the network number. Now you can click 

 *Debug>Add/Remove graphic trigger* 

.

LogicLab user manual 

143In both cases, the grey raised button containing the network number turns to green, and 

a white circle with the number of the trigger inside appears in the middle of the button, 

while the related trigger interface window pops up.

Note that unlike the other languages supported by LogicLab, LD does not allow you to 

insert a trigger before a single contact or coil, as it lets you select only an entire network. 

Thus the variables in the *Graphic trigger* window will be sampled every time the processor 

reaches the beginning of the selected network.

##### 9.6.2.6 ADDING A VARIABLE TO THE GRAPHIC TRIGGER FROM AN LD MODULE 

In order to watch the diagram of a variable, you need to add it to the *Graphic trigger*

window. Let us assume that you want to see the plot of the variable b in the LD code 

represented in the figure below.

To this purpose, click *Edit>Watch mode* .

The cursor will become as follows.

Now you can click the item representing the variable you wish to be shown in the *Graphic* 

*trigger* window. 

A dialog box appears listing all the currently existing instances of debug windows, and 

asking you which one is to receive the object you have just clicked.

144 

LogicLab user manualIn order to plot the curve of variable  b , select *Graphic trace* in the *Debug windows* col

umn, then press *OK*. The name of the variable is now printed in the *Track* column.

The same procedure applies to all the variables you wish to inspect.

Once you have added to the *Graphic watch* window all the variables you want to observe, 

you can click *Edit>Insert/Move mode* , so as to restore the original shape of the cursor.

Once the first variable is dropped into a graphic trace, the *Graphic properties* window is 

automatically shown and allows the user to setup sampling and visualization properties.

##### 9.6.2.7 OPENING THE GRAPHIC TRIGGER WINDOW FROM AN ST MODULE  

Let us assume that you have an ST module, also containing the following instructions.

LogicLab user manual 

145Let us also assume that you want to know the value of *x* and *y*, just before the *for* cycle is 

executed. To do so, move the cursor to line 6 and click *Debug>Add/Remove graphic trigger*

; a green arrowhead appears next to the line number, and the *Graphic trigger* window 

pops up.

Not all the ST instructions support triggers. For example, it is not possible to place a trig

ger on a line containing a terminator such as END_IF, END_FOR, END_WHILE, etc.

##### 9.6.2.8 ADDING A VARIABLE TO THE GRAPHIC TRIGGER WINDOW FROM AN ST  

 MODULE 

In order to get the diagram of a variable plotted, you need to add it to the *Graphic trigger*

window. To this purpose, select a variable, by double clicking it, and then drag it into the 

*Variables* window, that is the lower white box in the pop-up window. The variable now 

appears in the *Track* column.

The same procedure applies to all the variables you wish to inspect.

Once the first variable is dropped into a graphic trace, the *Graphic properties* window is 

automatically shown and allows the user to setup sampling and visualization properties.

146 

LogicLab user manual
##### 9.6.2.9 REMOVING A VARIABLE FROM THE GRAPHIC TRIGGER WINDOW 

If you want to remove a variable from the Graphic trigger window, select it by clicking its 

name once, then press the *Del* key.

##### 9.6.2.10 CLOSING THE GRAPHIC TRIGGER WINDOW AND REMOVING THE TRIGGER 

At the end of a debug session with the graphic trigger window you can choose between 

the following options:

\- Closing the *Graphic trigger* window.

\- Removing the trigger.

\- Removing all the triggers.

 Closing the graphic trigger window 

If you close a graphic trigger window youâ€™re just hiding its interface window, the trigger is 

still active. You will still see the green arrowhead (or the network highlighted).

You can reopen the interface window, to resume working with the same graphic trigger, 

by opening the *Trigger list* window, select the record referred to that trigger, and click 

the *Open* button.

 Removing the trigger 

If you choose this option, youâ€™ll completely remove the code both of the window manager 

and of its trigger. To do so: open the *Trigger list* window, select the record (having type 

LogicLab user manual 

147G) and click the *Remove* button.

Alternatively, you can move the cursor to the line (if the module is in IL or ST), or 

click the block (if the module is in FBD or LD) where you placed the trigger. Now select 

 *Debug>Add/Remove graphic trigger*

 Removing all the triggers 

This way youâ€™ll remove all the existing triggers at once, regardless for which records are 

selected. To do so: open the *Trigger list* window and click on the *Remove all* button.

### 9.7 BREAKPOINTS 

#### 9.7.1 THE BREAKPOINT TOOL 

The Breakpoint tool allows you to halt the program execution when it reaches a certain 

location. When a breakpoint is hit you can take all the time you want to watch other vari

ables values or check every condition you need t verify before resuming the program ex

ecution; with breakpoints you also have the option of executing only the next instruction, 

running your program step by step.

Breakpoints cannot be used with SFC modules.

##### 9.7.1.1 PRE-CONDITIONS TO SET A BREAKPOINT 

 No need for special compilation 

LogicLab debugging tools operate at run-time. Thus, unlike other programming languages

such as C++, the compiler does not need to be told whether or not to support break

points: given a PLC code, the compilerâ€™s output is unique, and there is no distinction

between debug and release version.

 Memory availability 

148 

LogicLab user manualA breakpoint takes a segment in the application code sector, having a well-defined

length. Obviously, in order to set a breakpoint, it is necessary that a sufficient amount of

memory is available, otherwise an error message appears.

 Incompatibility with graphic trigger windows 

A graphic trigger window takes the whole free space of the application code sector. There

fore, once such a debugging tool has been started, it is not possible to add any break

point, and an error message appears if you attempt to set one. Once the

graphic trigger window is eventually closed, breakpoints are enabled again.

Note that all the breakpoints existing before the starting of a graphic trigger window will

keep working normally. You are simply not allowed to add new ones.

#### 9.7.2 SET AND REMOVE A BREAKPOINT 

From the *Debug* menu you can select the appropriate voice for work with breakpoints.

Breakpoints can be palced only if a valid connection is established and the PLC is currently

executing.

From the Debug menu you can choose the following voices:

 Command 

 Icon in  

 debug  

 toolbar 

 Description 

*Set/Remove breakpoint*

In order to actually set a breakpoint, select the 

point of the PLC code where to insert the relative 

breakpoint and then select this voice or use the 

shortcut pressing *F12.*

Do the same to remove the breakpoint.

*Run*

One a breakpoint is hit, the program execution 

will be stopped and its state will become *HALTED*; 

in order to resume the normal program execution 

select this voice.

*Step*

Once a breakpoint is hit, the program execution 

will be stopped and its state will become HALTED; 

select this voice to execute only the next 

instruction.

*Remove all breakpoints* 

Selecting this voice will cause all the existing 

breakpoints to be removed simultaneously. 

*Breakpoint list* 

Select this voice to open a dialog listing all the 

existing breakpoints.

If you have set several breakpoint, you may want to keep control over them using the 

*Breakpoints list* window. Selecting the *Breakpoints list* voice the following window will be 

opened:

LogicLab user manual 

149In this window you can see the list of all active breakpoints, the program name and the 

relative code line where they are set is shown in the column *Module* and *Line* respectively.

Once selected a breakpoint from the list, you can:

\- *press the Open button*: the relative program will be opened and the line with the select

ed breakpoint will be highlighted; this feature allows you to fast navigate to the desired 

breakpoint. You can obtain the same result by double clicking the breakpoint instead of 

selecting it and then pressing the *Open* button

\- *press Remove button*: this will actually remove the selected breakpoint.

\- *press Remove all button*: this will remove all breakpoints in every program.

#### 9.7.3 WORKING WITH BREAKPOINTS 

##### 9.7.3.1 USE BREAKPOINTS WITH IL AND ST LANGUAGES 

Breakpoints work the same way in both IL and ST languages; in order to set a new break

point, move to the code line where you want to halt the program execution, then choose 

 *Debug>Set/Remove breakpoint* .

At the far left side of the code line, left to the line number, a red circle will appear, mean

ing that thereâ€™s a breakpoint on that line.

Note that you cannot set breakpoints on every instruction, for example you cannot set a 

breakpoint on an *end_if* statement and similar.

When a breakpoint is hit (which means that the code execution has reached the line 

where the breakpoint is set), the whole line is highlighted and a yellow arrow appears 

inside the red circle, to indicate that the program is waiting to execute that instruction.

Also the program execution state will change, in the far bottom-right corner, it will change 

from running to halted.

150 

LogicLab user manualNote that when a breakpoint is hit, the program execution is halted *before* that instruc

tion took place.

In the following image you can see that if we halt the program execution on an addition 

instruction, the addition hans not yet took place.

Selecting *Debug > Run* the program execution will be resumed until another break

point is hit, or the same breakpoint will be hit again after an entire cicle has took place.

Selecting *Debug > Step* the code line where the program execution has halted, will 

be executed, but the program will halt on the very next instruction. In other words, the 

result is the same as setting a new virtual breakpoint to the next instruction and then 

resume the execution.

##### 9.7.3.2 USE BREAKPOINTS WITH LD AND FBD LANGUAGES 

Breakpoints work the same way in both LD and FBD languages; in order to set a new 

breakpoint, move to the line where you want to halt the program execution, then choose 

 *Debug > Set/remove breakpoint* .

On the header of the line, the gray raised button with the line number on it, will now ap

pera a red circle, meaning that thereâ€™s a breakpoint on that line.

When a breakpoint is hit (which means that the code execution has reached the line 

where the breakpoint is set), the header is highlighted to indicate that the program is 

waiting to execute that instruction.

Also the program execution state will change, in the far bottom-right corner, it will change 

from running to halted.

LogicLab user manual 

151Note that, as shown with the textual languages, when a breakpoint is hit, the program 

execution is halted *before* that instruction took place.

Selecting *Debug > Run* the program execution will be resumed until another break

point is hit, or the same breakpoint will be hit again after an entire cicle has took place.

Selecting *Debug > Step* the line where the program execution has halted, will be ex

ecuted, but the program will halt on the very next instruction. In other words, the result 

is the same as setting a new virtual breakpoint to the next instruction and then resume 

the execution.

#### 9.7.4 REMOVING BREAKPOINTS 

To remove a breakpoint you can either select it from the *breakpoints list* window and 

press the *Remove* button, or you can move to the line where the breakpoint is and se

lect *Debug > Set/remove breakpoint* .

If you have done using breakpoints and you wish to remove them all with a single com

mand, you can either open the *breakpoints list* window and press the *Remove all* but

ton, or you can select the *Debug > Remove all breakpoints* .

152 

LogicLab user manual 
